[{"content":"Motivation 컴퓨터 구조를 공부하면서 스마트폰의 AP, SoC가 어떤 것에 대응되는지 궁금. Overview 컴퓨터의 CPU와 대응되는 것이 스마트폰의 AP, SoC ? 하지만 컴퓨터 구조와 스마트폰에서의 컴퓨터 구조는 약간 다름 Apple Silicon이 SoC에 해당 목차 컴퓨터 시스템 구조 SoC와 AP의 관계 Apple Silicon (Apple SoC) iPhone 구조와 PC 구조의 대략적인 비교 Apple Silicon 구조 정리 컴퓨터 시스템 구조 flowchart LR subgraph COMPUTER[\u0026#34;Computer\u0026#34;] CPU[\u0026#34;CPU\u0026#34;] MODE[\u0026#34;Mode\u0026lt;br/\u0026gt;Bit\u0026#34;] DMA[\u0026#34;DMA\u0026lt;br/\u0026gt;Controller\u0026#34;] TIMER[\u0026#34;Timer\u0026#34;] MEM_CTRL[\u0026#34;Memory\u0026lt;br/\u0026gt;Controller\u0026#34;] subgraph MEMORY[\u0026#34;Memory\u0026#34;] PROG1[\u0026#34;Program\u0026#34;] PROG2[\u0026#34;Program\u0026#34;] OS[\u0026#34;O/S\u0026#34;] end CPU --- MODE MODE --- DMA DMA --- TIMER MODE --- MEM_CTRL MEM_CTRL --- MEMORY end subgraph IO[\u0026#34;I/O Device\u0026#34;] subgraph HD[\u0026#34;Hard Disk\u0026#34;] DC1[\u0026#34;Device\u0026lt;br/\u0026gt;Controller\u0026#34;] --- BUF1[\u0026#34;Buffer\u0026#34;] end subgraph KB[\u0026#34;Keyboard\u0026#34;] DC2[\u0026#34;Device\u0026lt;br/\u0026gt;Controller\u0026#34;] --- BUF2[\u0026#34;Buffer\u0026#34;] end subgraph PR[\u0026#34;Print\u0026#34;] DC3[\u0026#34;Device\u0026lt;br/\u0026gt;Controller\u0026#34;] --- BUF3[\u0026#34;Buffer\u0026#34;] end subgraph MO[\u0026#34;Monitor\u0026#34;] DC4[\u0026#34;Device\u0026lt;br/\u0026gt;Controller\u0026#34;] --- BUF4[\u0026#34;Buffer\u0026#34;] end end TIMER --- DC1 TIMER --- DC2 TIMER --- DC3 TIMER --- DC4 style COMPUTER fill:#fff,stroke:#1976d2,stroke-width:2px style IO fill:#fff,stroke:#1976d2,stroke-width:2px style CPU fill:#ffcdd2,stroke:#c62828,stroke-width:2px style MEMORY fill:#ffcdd2,stroke:#c62828,stroke-width:2px style HD fill:#ffcdd2,stroke:#c62828,stroke-width:2px style MODE fill:#fff,stroke:#333 style DMA fill:#fff,stroke:#333 style TIMER fill:#fff,stroke:#333 style MEM_CTRL fill:#fff,stroke:#333 style KB fill:#e8f5e9,stroke:#388e3c style PR fill:#e8f5e9,stroke:#388e3c style MO fill:#e8f5e9,stroke:#388e3c 컴퓨터 시스템 구조: 컴퓨터 I/O 디바이스 우리가 흔히 말하는 컴퓨터 구조 핵심 요소: CPU (중앙처리장치) 메모리 (주기억장치) 디스크 (보조기억장치) SoC와 AP의 관계 SoC (System on Chip) \u0026lsquo;시스템을 한 칩에 통합\u0026rsquo; CPU/GPU/NPU(신경망)/ISP(카메라)/DSP/메모리 컨트롤러/보안 영역 같은 것들이 들어있는 통합 칩 전체 AP (Application Processor) \u0026lsquo;앱을 돌리는 메인 프로세서(연산 중심)\u0026rsquo; 모바일 업계에서 보통 메인 칩(=사실상 SoC)을 AP라고 부르는 관행이 생김. 특히 한국/스마트폰 맥락에서 “AP 뭐야?” 하면 대개 그 폰의 메인 SoC를 뜻함. 퀄컴 Snapdragon, 삼성 Axynos를 보통 “AP”라고도 부르지만, 기술적으로는 전형적인 SoC Apple은 문서/기술 설명에서 SoC라는 표현을 많이 사용하며, 공식 용어집에서 SoC를 “여러 구성요소를 단일 칩으로 통합한 IC”로 정의 Apple 용어집 참고 Apple Silicon (Apple SoC) Apple의 SoC A-시리즈(iPhone) M-시리즈(Mac) Application Processor, Secure Enclave 등 구성 요소를 SoC 일부로 설명 iPhone 구조와 PC 구조의 대략적인 비교 flowchart TB subgraph PC[\u0026#34;🖥️ PC\u0026#34;] PC_CPU[\u0026#34;CPU\u0026#34;] PC_GPU[\u0026#34;GPU (별도)\u0026#34;] PC_RAM[\u0026#34;RAM\u0026#34;] PC_SSD[\u0026#34;SSD\u0026#34;] end subgraph iPhone[\u0026#34;📱 iPhone\u0026#34;] subgraph AP[\u0026#34;SoC ( ⊃ AP)\u0026#34;] IP_CPU[\u0026#34;CPU\u0026#34;] IP_GPU[\u0026#34;GPU\u0026#34;] IP_NPU[\u0026#34;NPU\u0026#34;] end IP_RAM[\u0026#34;RAM\u0026#34;] IP_FLASH[\u0026#34;Flash Storage\u0026#34;] end style PC fill:#e3f2fd style iPhone fill:#fff8e1 style AP fill:#fce4ec Apple Silicon 구조 graph TD subgraph SoC[\u0026#34;SoC (System on Chip)\u0026#34;] AP[\u0026#34;AP\u0026lt;br/\u0026gt;(CPU:\u0026lt;br/\u0026gt;P-core + E-core)\u0026#34;]:::cpu GPU[\u0026#34;GPU\u0026#34;]:::gpu NPU[\u0026#34;Neural Engine\u0026lt;br/\u0026gt;(NPU)\u0026#34;]:::npu ISP[\u0026#34;ISP\u0026lt;br/\u0026gt;(Image Signal Processor)\u0026#34;]:::isp MEM[\u0026#34;Memory Controller\u0026lt;br/\u0026gt;(UMA: LPDDR5X)\u0026#34;]:::mem SEC[\u0026#34;Secure Enclave\u0026#34;]:::sec MOD[\u0026#34;Modem\u0026lt;br/\u0026gt;(5G Baseband 등)\u0026#34;]:::mod end classDef cpu fill:#ffcdd2,stroke:#c62828,stroke-width:2px classDef gpu fill:#f3e5f5,stroke:#7b1fa2 classDef npu fill:#e8f5e9,stroke:#388e3c classDef isp fill:#fff3e0,stroke:#f57c00 classDef mem fill:#e0f2f1,stroke:#00695c classDef sec fill:#fce4ec,stroke:#c2185b classDef mod fill:#f5f5f5,stroke:#424242 정리 제품 스펙에서 AP ≈ SoC 로 흔하게 인식되지만 엄밀하게 구분하면 AP는 SoC 중 앱/연산을 담당하는 중심 칩 (SoC ⊃ AP) Apple 플랫폼에서는 SoC 표현을 더 많이 사용 References 👀 Apple SoC 보안 용어집 ","permalink":"http://yeniful.github.io/posts/2026/apple-soc/","summary":"\u003ch2 id=\"motivation\"\u003eMotivation\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e컴퓨터 구조를 공부하면서 스마트폰의 AP, SoC가 어떤 것에 대응되는지 궁금.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e컴퓨터의 CPU와 대응되는 것이 스마트폰의 AP, SoC ?\n\u003cul\u003e\n\u003cli\u003e하지만 컴퓨터 구조와 스마트폰에서의 컴퓨터 구조는 약간 다름\u003c/li\u003e\n\u003cli\u003eApple Silicon이 SoC에 해당\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e목차\n\u003cul\u003e\n\u003cli\u003e컴퓨터 시스템 구조\u003c/li\u003e\n\u003cli\u003eSoC와 AP의 관계\u003c/li\u003e\n\u003cli\u003eApple Silicon (Apple SoC)\u003c/li\u003e\n\u003cli\u003eiPhone 구조와 PC 구조의 대략적인 비교\u003c/li\u003e\n\u003cli\u003eApple Silicon 구조\u003c/li\u003e\n\u003cli\u003e정리\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"컴퓨터-시스템-구조\"\u003e컴퓨터 시스템 구조\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003eflowchart LR\n    subgraph COMPUTER[\u0026#34;Computer\u0026#34;]\n        CPU[\u0026#34;CPU\u0026#34;]\n        MODE[\u0026#34;Mode\u0026lt;br/\u0026gt;Bit\u0026#34;]\n        DMA[\u0026#34;DMA\u0026lt;br/\u0026gt;Controller\u0026#34;]\n        TIMER[\u0026#34;Timer\u0026#34;]\n        MEM_CTRL[\u0026#34;Memory\u0026lt;br/\u0026gt;Controller\u0026#34;]\n        \n        subgraph MEMORY[\u0026#34;Memory\u0026#34;]\n            PROG1[\u0026#34;Program\u0026#34;]\n            PROG2[\u0026#34;Program\u0026#34;]\n            OS[\u0026#34;O/S\u0026#34;]\n        end\n        \n        CPU --- MODE\n        MODE --- DMA\n        DMA --- TIMER\n        MODE --- MEM_CTRL\n        MEM_CTRL --- MEMORY\n    end\n    \n    subgraph IO[\u0026#34;I/O Device\u0026#34;]\n        subgraph HD[\u0026#34;Hard Disk\u0026#34;]\n            DC1[\u0026#34;Device\u0026lt;br/\u0026gt;Controller\u0026#34;] --- BUF1[\u0026#34;Buffer\u0026#34;]\n        end\n        subgraph KB[\u0026#34;Keyboard\u0026#34;]\n            DC2[\u0026#34;Device\u0026lt;br/\u0026gt;Controller\u0026#34;] --- BUF2[\u0026#34;Buffer\u0026#34;]\n        end\n        subgraph PR[\u0026#34;Print\u0026#34;]\n            DC3[\u0026#34;Device\u0026lt;br/\u0026gt;Controller\u0026#34;] --- BUF3[\u0026#34;Buffer\u0026#34;]\n        end\n        subgraph MO[\u0026#34;Monitor\u0026#34;]\n            DC4[\u0026#34;Device\u0026lt;br/\u0026gt;Controller\u0026#34;] --- BUF4[\u0026#34;Buffer\u0026#34;]\n        end\n    end\n    \n    TIMER --- DC1\n    TIMER --- DC2\n    TIMER --- DC3\n    TIMER --- DC4\n    \n    style COMPUTER fill:#fff,stroke:#1976d2,stroke-width:2px\n    style IO fill:#fff,stroke:#1976d2,stroke-width:2px\n    \n    style CPU fill:#ffcdd2,stroke:#c62828,stroke-width:2px\n    style MEMORY fill:#ffcdd2,stroke:#c62828,stroke-width:2px\n    style HD fill:#ffcdd2,stroke:#c62828,stroke-width:2px\n    \n    style MODE fill:#fff,stroke:#333\n    style DMA fill:#fff,stroke:#333\n    style TIMER fill:#fff,stroke:#333\n    style MEM_CTRL fill:#fff,stroke:#333\n    style KB fill:#e8f5e9,stroke:#388e3c\n    style PR fill:#e8f5e9,stroke:#388e3c\n    style MO fill:#e8f5e9,stroke:#388e3c\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e컴퓨터 시스템 구조:\n\u003cul\u003e\n\u003cli\u003e컴퓨터\u003c/li\u003e\n\u003cli\u003eI/O 디바이스\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e우리가 흔히 말하는 \u003ca href=\"https://wikidocs.net/111325\"\u003e컴퓨터 구조\u003c/a\u003e 핵심 요소:\n\u003cul\u003e\n\u003cli\u003eCPU (중앙처리장치)\u003c/li\u003e\n\u003cli\u003e메모리 (주기억장치)\u003c/li\u003e\n\u003cli\u003e디스크 (보조기억장치)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"soc와-ap의-관계\"\u003eSoC와 AP의 관계\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSoC (System on Chip)\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u0026lsquo;시스템을 한 칩에 통합\u0026rsquo;\u003c/li\u003e\n\u003cli\u003eCPU/GPU/NPU(신경망)/ISP(카메라)/DSP/메모리 컨트롤러/보안 영역 같은 것들이 들어있는 \u003cstrong\u003e통합 칩 전체\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAP (Application Processor)\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u0026lsquo;앱을 돌리는 메인 프로세서(연산 중심)\u0026rsquo;\u003c/li\u003e\n\u003cli\u003e모바일 업계에서 보통 메인 칩(=사실상 SoC)을 AP라고 부르는 관행이 생김.\u003c/li\u003e\n\u003cli\u003e특히 한국/스마트폰 맥락에서 “AP 뭐야?” 하면 대개 \u003cstrong\u003e그 폰의 메인 SoC\u003c/strong\u003e를 뜻함.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e퀄컴 Snapdragon, 삼성 Axynos를 보통 “AP”라고도 부르지만, 기술적으로는 전형적인 SoC\u003c/li\u003e\n\u003cli\u003eApple은 문서/기술 설명에서 SoC라는 표현을 많이 사용하며, 공식 용어집에서 SoC를 “여러 구성요소를 단일 칩으로 통합한 IC”로 정의 \u003ca href=\"https://support.apple.com/ko-kr/guide/security/sec93292bfa6/1/web/1\"\u003eApple 용어집 참고\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"apple-silicon-apple-soc\"\u003eApple Silicon (Apple SoC)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eApple의 SoC\n\u003cul\u003e\n\u003cli\u003eA-시리즈(iPhone)\u003c/li\u003e\n\u003cli\u003eM-시리즈(Mac)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eApplication Processor, Secure Enclave 등 구성 요소를 SoC 일부로 설명\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"iphone-구조와-pc-구조의-대략적인-비교\"\u003eiPhone 구조와 PC 구조의 대략적인 비교\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003eflowchart TB\n    subgraph PC[\u0026#34;🖥️ PC\u0026#34;]\n        PC_CPU[\u0026#34;CPU\u0026#34;]\n        PC_GPU[\u0026#34;GPU (별도)\u0026#34;]\n        PC_RAM[\u0026#34;RAM\u0026#34;]\n        PC_SSD[\u0026#34;SSD\u0026#34;]\n    end\n    \n    subgraph iPhone[\u0026#34;📱 iPhone\u0026#34;]\n        subgraph AP[\u0026#34;SoC ( ⊃ AP)\u0026#34;]\n            IP_CPU[\u0026#34;CPU\u0026#34;]\n            IP_GPU[\u0026#34;GPU\u0026#34;]\n            IP_NPU[\u0026#34;NPU\u0026#34;]\n        end\n        IP_RAM[\u0026#34;RAM\u0026#34;]\n        IP_FLASH[\u0026#34;Flash Storage\u0026#34;]\n    end\n    \n    style PC fill:#e3f2fd\n    style iPhone fill:#fff8e1\n    style AP fill:#fce4ec\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"apple-silicon-구조\"\u003eApple Silicon 구조\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003egraph TD\n    subgraph SoC[\u0026#34;SoC (System on Chip)\u0026#34;]\n        AP[\u0026#34;AP\u0026lt;br/\u0026gt;(CPU:\u0026lt;br/\u0026gt;P-core + E-core)\u0026#34;]:::cpu\n        GPU[\u0026#34;GPU\u0026#34;]:::gpu\n        NPU[\u0026#34;Neural Engine\u0026lt;br/\u0026gt;(NPU)\u0026#34;]:::npu\n        ISP[\u0026#34;ISP\u0026lt;br/\u0026gt;(Image Signal Processor)\u0026#34;]:::isp\n        MEM[\u0026#34;Memory Controller\u0026lt;br/\u0026gt;(UMA: LPDDR5X)\u0026#34;]:::mem\n        SEC[\u0026#34;Secure Enclave\u0026#34;]:::sec\n        MOD[\u0026#34;Modem\u0026lt;br/\u0026gt;(5G Baseband 등)\u0026#34;]:::mod\n    end\n    \n    classDef cpu fill:#ffcdd2,stroke:#c62828,stroke-width:2px\n    classDef gpu fill:#f3e5f5,stroke:#7b1fa2\n    classDef npu fill:#e8f5e9,stroke:#388e3c\n    classDef isp fill:#fff3e0,stroke:#f57c00\n    classDef mem fill:#e0f2f1,stroke:#00695c\n    classDef sec fill:#fce4ec,stroke:#c2185b\n    classDef mod fill:#f5f5f5,stroke:#424242\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"정리\"\u003e정리\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e제품 스펙에서 \u003cstrong\u003eAP ≈ SoC\u003c/strong\u003e 로 흔하게 인식되지만\u003c/li\u003e\n\u003cli\u003e엄밀하게 구분하면 \u003cstrong\u003eAP는 SoC 중 앱/연산을 담당하는 중심 칩\u003c/strong\u003e (\u003cstrong\u003eSoC ⊃ AP\u003c/strong\u003e)\u003c/li\u003e\n\u003cli\u003eApple 플랫폼에서는 SoC 표현을 더 많이 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"references-\"\u003eReferences 👀\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://support.apple.com/ko-kr/guide/security/sec87716a080/web\"\u003eApple SoC 보안\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://support.apple.com/ko-kr/guide/security/sec93292bfa6/1/web/1\"\u003e용어집\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"[Apple Platforms] SoC (System on a Chip)와 AP (Application Processor)"},{"content":"Motivation 2020년에 샀던 마지막 인텔 맥. 터치바가 좋아서 큰 마음 먹고 16인치를 샀는데… M1 맥북이 생기자마자 바로 애물단지가 되어버렸다. “콘텐츠 감상용으로 쓸까? 아님 서버처럼 쓸까?” 고민하던 중, 요즘 유행하는 개인화 Agent 도구인 openclaw를 세팅하면 좋겠다는 생각이 들었다. 메인으로 쓰고있는 맥북은 보안/권한 이슈가 생길 수 있으니 딱이였다.\nOpenclaw란? 개인 비서형 Agent 도구 🦀 로컬/앱 접근 권한을 열어두면, 내가 구독 중인 모델 provider와 연결해서 비서처럼 쓸 수 있다. 이름을 벌써 세 번째 바꾼 도구… (찾을 땐 ClawdBot / MoltBot / Openclaw 키워드로 검색 중) “맥미니 품절 대란”의 원인(?)으로도 종종 언급된다. Telegram ✈️ WhatsApp, Telegram, Slack, Discord 등 다양한 메신저/커뮤니티 도구와 함께 쓸 수 있는데, 나는 개인용이라 Telegram으로 세팅했다. @BotFather에게 메시지를 보낸 후 /start 명령어를 입력하면 내 봇 계정을 만들어주고 토큰을 만들어준다. 만들어준 토큰을 openclaw에 연동해서 사용하면 된다.\n좋은 점 예전에 Obsidian에서 쓰던 일기를 Apple Notes에 쓰고 있다. 그런데 Apple Notes는 AI 활용을 하려면 늘 한계가 있었다.\nChatGPT로 붙여 쓰려고 하면 노트 1개만 참고되는 경우가 많고 로컬에서 돌리려면 노트를 파일로 export해야 해서 꽤 번거롭다 openclaw에서 Apple Notes 권한을 열어두니, 노트 요약, \b수정, 회고 작업이 확실히 편해졌다. 무엇보다 웹과 앱에서 할 수 있는 것들을 하나의 흐름으로 연결이 가능하다는 점이 있었다. 포매팅이 필요하지만 “잡코리아에서 iOS 채용공고 검색해서 Apple Notes 오늘의 일기에 넣어줘”와 같은 동작이 가능하다.\n일상 속에서 간소화, 자동화하고싶은 플로우들을 찾아서 활용해봐야겠다. 나중에 메인 맥에 세팅해서 텔레그램으로 작업을 시켜도 재밌겠다.\n아쉬운 점 보안 문제 제대로 쓰려면 권한을 다 열어줘야 한다. 그래서 메인 맥북엔 세팅하지 않고, 서브 맥북에만 세팅했다. 연결이 불안정하다. 가끔 끊기거나, 기대한 만큼 매끄럽지 않을 때가 있다. Tip Agent류는 기본적으로 켜져 있어야 쓸 수 있다.\n전원 케이블을 연결해두고 디스플레이가 꺼져도 잠자지 않게 설정하거나 터미널에서 caffeinate로 잠자기 방지하기 caffeinate -i : 시스템 잠자기 방지 caffeinate -s : 전원 연결 시 잠자기 방지 caffeinate -i -s : 둘 다 디스플레이까지 안 꺼지게 하려면 -d 옵션 ","permalink":"http://yeniful.github.io/posts/2026/tools-openclaw/","summary":"\u003ch2 id=\"motivation\"\u003eMotivation\u003c/h2\u003e\n\u003cp\u003e2020년에 샀던 마지막 인텔 맥. 터치바가 좋아서 큰 마음 먹고 16인치를 샀는데… M1 맥북이 생기자마자 바로 애물단지가 되어버렸다. “콘텐츠 감상용으로 쓸까? 아님 서버처럼 쓸까?” 고민하던 중, 요즘 유행하는 개인화 Agent 도구인 \u003cstrong\u003eopenclaw\u003c/strong\u003e를 세팅하면 좋겠다는 생각이 들었다. 메인으로 쓰고있는 맥북은 보안/권한 이슈가 생길 수 있으니 딱이였다.\u003c/p\u003e\n\u003ch2 id=\"openclaw란\"\u003eOpenclaw란?\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e개인 비서형 Agent 도구 🦀\u003c/li\u003e\n\u003cli\u003e로컬/앱 접근 권한을 열어두면, 내가 구독 중인 모델 provider와 연결해서 비서처럼 쓸 수 있다.\u003c/li\u003e\n\u003cli\u003e이름을 벌써 세 번째 바꾼 도구… (찾을 땐 \u003cstrong\u003eClawdBot / MoltBot / Openclaw\u003c/strong\u003e 키워드로 검색 중)\u003c/li\u003e\n\u003cli\u003e“맥미니 품절 대란”의 원인(?)으로도 종종 언급된다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"telegram-\"\u003eTelegram ✈️\u003c/h2\u003e\n\u003cp\u003eWhatsApp, Telegram, Slack, Discord 등 다양한 메신저/커뮤니티 도구와 함께 쓸 수 있는데, 나는 개인용이라 \u003cstrong\u003eTelegram\u003c/strong\u003e으로 세팅했다. @BotFather에게 메시지를 보낸 후 /start 명령어를 입력하면 내 봇 계정을 만들어주고 토큰을 만들어준다. 만들어준 토큰을 openclaw에 연동해서 사용하면 된다.\u003c/p\u003e","title":"[도구] openclaw를 써보자 🦀  🖋️"},{"content":"Motivation iOS 개발에서 UI 업데이트는 반드시 메인 스레드에서 해야 하지만, Swift Concurrency 도입 후 백그라운드 Task 내에서 UI를 직접 업데이트하는 실수가 쉬워졌다. @MainActor는 컴파일 타임부터 이 문제를 구조적으로 해결해 준다. 이 글에서 MainActor에 대해 다뤄보려고 한다.\nTask { // 백그라운드 Task (Global Actor) let data = await fetchUser() userNameLabel.text = data.name // UI 업데이트 (MainActor 필요!) } Overview 1. MainActor는 언제 필요할까? (문제 상황) 1-1. UIKit의 메인 스레드 제약 1-2. GCD의 한계 (DispatchQueue.main.async) 1-3. Swift Concurrency의 함정 (Task + UI 섞기) 2. MainActor 기본 개념 2-1. MainActor 알기 전 Actor가 무엇인지 2-2. Global Actor와 MainActor 2-3. @MainActor 속성의 의미 3. 사용법 3-1. 함수/프로퍼티에 적용 3-2. 클래스 전체에 적용 (ViewModel 패턴) 3-3. SwiftUI와의 완벽 호환 (@Published) 4. Task와 함께 사용 4-1. Task { @MainActor in } 4-2. await MainActor.run { } 4-3. Task.detached + MainActor 전환 5. 더 알아보기 5-1. nonisolated 탈출구 5-2. @Sendable과 데이터 전달 5-3. MainActor 호핑 최적화 6. MainActor와 DispatchQueue 비교 6-1. @MainActor vs DispatchQueue.main 6-2. 다른 글로벌 액터와 비교 References 👀 ","permalink":"http://yeniful.github.io/posts/2026/swift-mainactor/","summary":"\u003ch2 id=\"motivation\"\u003eMotivation\u003c/h2\u003e\n\u003cp\u003eiOS 개발에서 UI 업데이트는 \u003cstrong\u003e반드시 메인 스레드\u003c/strong\u003e에서 해야 하지만, Swift Concurrency 도입 후 백그라운드 Task 내에서 UI를 직접 업데이트하는 실수가 쉬워졌다. @MainActor는 컴파일 타임부터 이 문제를 구조적으로 해결해 준다. 이 글에서 MainActor에 대해 다뤄보려고 한다.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-Swift\" data-lang=\"Swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eTask { \u003cspan style=\"color:#75715e\"\u003e// 백그라운드 Task (Global Actor)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e data = await fetchUser()      \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    userNameLabel.text = data.name  \u003cspan style=\"color:#75715e\"\u003e// UI 업데이트 (MainActor 필요!)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003ch2 id=\"1-mainactor는-언제-필요할까-문제-상황\"\u003e1. MainActor는 언제 필요할까? (문제 상황)\u003c/h2\u003e\n\u003ch3 id=\"1-1-uikit의-메인-스레드-제약\"\u003e1-1. UIKit의 메인 스레드 제약\u003c/h3\u003e\n\u003ch3 id=\"1-2-gcd의-한계-dispatchqueuemainasync\"\u003e1-2. GCD의 한계 (DispatchQueue.main.async)\u003c/h3\u003e\n\u003ch3 id=\"1-3-swift-concurrency의-함정-task--ui-섞기\"\u003e1-3. Swift Concurrency의 함정 (Task + UI 섞기)\u003c/h3\u003e\n\u003ch2 id=\"2-mainactor-기본-개념\"\u003e2. MainActor 기본 개념\u003c/h2\u003e\n\u003ch3 id=\"2-1-mainactor-알기-전-actor가-무엇인지\"\u003e2-1. MainActor 알기 전 Actor가 무엇인지\u003c/h3\u003e\n\u003ch3 id=\"2-2-global-actor와-mainactor\"\u003e2-2. Global Actor와 MainActor\u003c/h3\u003e\n\u003ch3 id=\"2-3-mainactor-속성의-의미\"\u003e2-3. \u003ccode\u003e@MainActor\u003c/code\u003e 속성의 의미\u003c/h3\u003e\n\u003ch2 id=\"3-사용법\"\u003e3. 사용법\u003c/h2\u003e\n\u003ch3 id=\"3-1-함수프로퍼티에-적용\"\u003e3-1. 함수/프로퍼티에 적용\u003c/h3\u003e\n\u003ch3 id=\"3-2-클래스-전체에-적용-viewmodel-패턴\"\u003e3-2. 클래스 전체에 적용 (ViewModel 패턴)\u003c/h3\u003e\n\u003ch3 id=\"3-3-swiftui와의-완벽-호환-published\"\u003e3-3. SwiftUI와의 완벽 호환 (@Published)\u003c/h3\u003e\n\u003ch2 id=\"4-task와-함께-사용\"\u003e4. Task와 함께 사용\u003c/h2\u003e\n\u003ch3 id=\"4-1-task--mainactor-in-\"\u003e4-1. \u003ccode\u003eTask { @MainActor in }\u003c/code\u003e\u003c/h3\u003e\n\u003ch3 id=\"4-2-await-mainactorrun--\"\u003e4-2. \u003ccode\u003eawait MainActor.run { }\u003c/code\u003e\u003c/h3\u003e\n\u003ch3 id=\"4-3-taskdetached--mainactor-전환\"\u003e4-3. \u003ccode\u003eTask.detached\u003c/code\u003e + MainActor 전환\u003c/h3\u003e\n\u003ch2 id=\"5-더-알아보기\"\u003e5. 더 알아보기\u003c/h2\u003e\n\u003ch3 id=\"5-1-nonisolated-탈출구\"\u003e5-1. \u003ccode\u003enonisolated\u003c/code\u003e 탈출구\u003c/h3\u003e\n\u003ch3 id=\"5-2-sendable과-데이터-전달\"\u003e5-2. \u003ccode\u003e@Sendable\u003c/code\u003e과 데이터 전달\u003c/h3\u003e\n\u003ch3 id=\"5-3-mainactor-호핑-최적화\"\u003e5-3. MainActor 호핑 최적화\u003c/h3\u003e\n\u003ch2 id=\"6-mainactor와-dispatchqueue-비교\"\u003e6. MainActor와 DispatchQueue 비교\u003c/h2\u003e\n\u003ch3 id=\"6-1-mainactor-vs-dispatchqueuemain\"\u003e6-1. \u003ccode\u003e@MainActor\u003c/code\u003e vs \u003ccode\u003eDispatchQueue.main\u003c/code\u003e\u003c/h3\u003e\n\u003ch3 id=\"6-2-다른-글로벌-액터와-비교\"\u003e6-2. 다른 글로벌 액터와 비교\u003c/h3\u003e\n\u003ch3 id=\"references-\"\u003eReferences 👀\u003c/h3\u003e","title":"[Swift] MainActor 🖋️"},{"content":"Motivation 기능을 완전하게 구현하려면? 최근 과제 전형을 마치고 제출했던 코드를 다시 살펴보았다. 요구사항에 따라 동작하게 만들었지만 에러 핸들링, 예외 처리, 효율 측면에서 놓친 부분이 많았다는 걸 깨달았다. 단순히 기능을 구현하는 것과, 예상하지 못한 동작과 상태를 대비해서 잘 만드는 건 전혀 다른 문제였다. 과제에서 크게 신경을 쓰지 못한 Testing 영역이 눈에 들어왔고 \u0026lsquo;코드과 테스트 코드의 순서를 바꿨었더라면?\u0026lsquo;이라는 생각이 들었다. Code First 요구사항 확인 → 기능 개발 → 테스트 코드 작성 → 테스트\n기존 개발 플로우대로라면 보통 요구사항 확인 → 기능 개발 → 테스트 코드 작성 -\u0026gt; 테스트 실행 순서로 진행할 것 같다. \u0026lsquo;것 같다\u0026rsquo;로 이야기한 이유는, 실제 프로젝트에서 테스트 코드를 활용한 경험이 없기 때문이다. 이 순서로 작업을 할 경우 “내가 만든 기능이 맞다고 믿는 범위” 안에서만 테스트를 코드를 작성할 위험이 있겠다는 생각이 들었다. 내가 구현한 형태에 맞춰 테스트를 설계하게 되면, 확증 편향처럼 요구사항을 검증한다기보다 구현을 정당화하는 테스트가 될 것 같다. Test Code First 요구사항 확인 → 테스트 코드 작성 (예상 출력 수동 입력) → 기능 개발 -\u0026gt; 테스트 (실제 출력과 비교)\n그때 떠오른 방법이 “시나리오 기반 테스트를 먼저 만들고 개발을 시작하는 방식”이었다. 순서를 바꿔서, 요구사항 확인 → 테스트 코드 작성 → 개발의 이터레이션을 돌려보자는 생각을 했다. 특히 요구사항을 유저 시나리오로 풀어 테스트를 먼저 설계하면, “정상 입력만 들어온다”는 가정에서 벗어나 더 넓은 시야로 문제를 볼 수 있을 것 같았다. 예를 들어 실패 케이스(잘못된 입력, 빈 값, 중복 요청, 타임아웃 등)를 자연스럽게 떠올리게 되고, 그 과정에서 예외 처리와 에러 핸들링의 품질도 함께 올라갈 가능성이 크다. TDD와 BDD 테스트 코드에 대해 알아보면서, 내가 느낀 문제의식이 TDD와 관련있다는 것도 알게 되었다. TDD는 \u0026ldquo;테스트 먼저, 구현 나중\u0026rdquo; 원칙으로, Red(실패하는 테스트 작성) → Green(테스트 통과하는 최소 코드 작성) → Refactor(코드 개선) 사이클을 반복하며 개발하는 방법론이다. 동시에 내가 생각했던 \u0026ldquo;유저 시나리오 기반 테스트\u0026quot;를 더 확장한 개념이 BDD와 유사하다는 점도 흥미로웠다. BDD는 TDD에서 발전한 개념으로, 사용자 행동(Behavior) 관점에서 Given-When-Then 형식으로 테스트를 작성한다. 둘의 핵심 차이는 테스트 범위가 아니라 관점이다. TDD가 \u0026ldquo;이 함수가 올바르게 동작하는가?\u0026rdquo;, \u0026ldquo;성능은 어떠한가?\u0026ldquo;를 묻는다면, BDD는 \u0026ldquo;사용자가 X를 했을 때 Y가 일어나는가?\u0026ldquo;를 묻는다. TDD는 개발자 관점에서 코드의 정확성과 성능을, BDD는 사용자/비즈니스 관점에서 요구사항 충족을 검증한다. 둘 다 함께 쓰는 방법도 있을까 생각했는데, 검증하려는 영역이 여러 테스트 코드에 걸쳐 중복되거나 테스트 코드 작성에만 시간이 과도하게 쏟아질 위험(본말전도)도 있겠다는 생각이 들었다. AI 시대의 테스팅 AI 시대에 테스트 코드가 어떤 의미있는지 궁금해져서 영상을 찾아보다가 2025년 6월 켄트백의 TDD 토크를 발견했다. TDD, AI agent and coding with Kent Beck 내용을 짧게 요약하자면 다음과 같다. AI 시대의 사고방식: 비전과 설계 능력이 핵심 스킬로 부상 (비전 설정, 이정표 관리, 복잡성 제어) 언어 세부사항은 더 이상 중요하지 않음 실험의 양적 증가가 경쟁 우위 코드 양이 증가함에 따라 탐색된 아이디어의 양이 중요 \u0026ldquo;모든 것을 실험\u0026rdquo; 해봐야 하는 시대 켄트 백의 증강형 코딩 후기 번역도 재미있게 읽었다. (+ TDD를 위한 프롬프트) 야크털 깎기(yak shaving)라는 표현 재밌다. 아무튼 테스팅 이번 과제를 통해 하나의 수단이자 도구로서의 테스트 코드의 필요성을 체감했다. 개인 iOS 앱 프로젝트에서서 테스트 코드를 작성하며 배운 것들을 이 문서에 차근차근 정리해보려고 한다. Overview 테스트 코드의 목적 Testing의 종류 Apple Platforms 개발에서의 testing frameworks XCTest Swift Testing 좋은 테스트 작성 팁 XCTest 설명\nXcode 프로젝트에서 단위 테스트(Unit Test)를 작성하고, Xcode의 테스트 워크플로와 원활하게 통합되도록 설계된 Apple 공식 테스트 프레임워크. 역할 코드 실행 중 특정 조건이 충족되는지 검증하고, 조건이 만족되지 않으면 실패 기록. 코드 블록의 성능을 측정하여 성능 회귀 여부를 확인하는 성능 테스트를 제공. XCUIAutomation과 함께 사용할 경우, 앱의 UI를 자동으로 조작하여 실제 사용자 흐름을 검증하는 UI 테스트를 작성 가능 기본 구조 XCTestCase를 상속한 테스트 케이스 타입을 만들고, 이름이 test 로 시작하는 메서드를 정의. 해당 메서드를 개별 테스트로 인식. 테스트 메서드 안에서 XCTAssertEqual, XCTAssertTrue 등 다양한 assertion 함수를 사용해 기대 값과 실제 값을 비교 Xcode와의 통합 테스트는 Xcode 내에서 빌드-실행-결과 확인까지 한 흐름으로 처리 Test navigator나 스킴에서 손쉽게 실행 가능 UI 자동화 테스트는 여러 기기, 언어, 지역 설정, 환경 조건에서 재실행 가능 사용자 경험을 폭넓게 검증하는 데 활용 Swift Testing과의 관계 Swift Testing은 새로운 테스트 프레임워크 XCTest와 비슷한 기능을 제공하지만 다른 문법과 동시성 모델을 사용. UI 자동화(XCUIApplication 등)나 성능 메트릭(XCTMetric 등)을 사용하는 테스트, Objective-C 기반 테스트는 여전히 XCTest를 사용해야 함 References 👀 Apple Developer Testing TDD, AI Agents and Coding - 켄트백 원문 TDD, AI Agents and Coding - 켄트백 번역 및 요약 (Geeknews) iOS 개발자의 쉽게 쓰는 테스트코드, TDD의 생활화(1)-구조와 방식 뱅크샐러드 iOS팀이 숨쉬듯이 테스트코드 짜는 방식 1편 - 통합 UI테스트 실전에서 TDD하기 가독성 좋은 테스트 코드를 작성하는 방법 ","permalink":"http://yeniful.github.io/posts/2026/apple-testing/","summary":"\u003ch2 id=\"motivation\"\u003eMotivation\u003c/h2\u003e\n\u003ch3 id=\"기능을-완전하게-구현하려면\"\u003e기능을 완전하게 구현하려면?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e최근 과제 전형을 마치고 제출했던 코드를 다시 살펴보았다.\u003c/li\u003e\n\u003cli\u003e요구사항에 따라 동작하게 만들었지만 에러 핸들링, 예외 처리, 효율 측면에서 놓친 부분이 많았다는 걸 깨달았다.\u003c/li\u003e\n\u003cli\u003e단순히 기능을 구현하는 것과, 예상하지 못한 동작과 상태를 대비해서 잘 만드는 건 전혀 다른 문제였다.\u003c/li\u003e\n\u003cli\u003e과제에서 크게 신경을 쓰지 못한 Testing 영역이 눈에 들어왔고 \u0026lsquo;코드과 테스트 코드의 순서를 바꿨었더라면?\u0026lsquo;이라는 생각이 들었다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"code-first\"\u003eCode First\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e요구사항 확인 → 기능 개발 → 테스트 코드 작성 → 테스트\u003c/p\u003e","title":"[Apple Platforms] Testing 🖋️"},{"content":"캐시란? 자주 사용하는 데이터에 빠르게 접근할 수 있도록 데이터를 미리 복사해 놓은 고속 임시 저장소 매번 느린 원본 저장소에서 가져오는 것보다 빠르게 접근할 수 있음 주로 RAM같은 빠른 매체 사용. DB, 디스크, 네트워크처럼 느린 계층에 대한 접근 횟수 줄임 캐싱이란? 자주 사용하는 데이터에 빠르게 접근할 수 있도록 데이터를 임시 저장소(메모리, 디스크)에 복사해서 보관하는 기술 캐시 히트: 캐시에 해당 데이터가 있는 경우. 데이터가 반환됨 캐시 미스: 캐시에 해당 데이터가 없는 경우. 원본을 데이터에서 복사해서 캐시에 저장. 유의사항: 원본 데이터가 바뀌면 캐시도 갱신해야함. 캐시 예시: CPU 캐시부터 웹 브라우저, 앱 이미지 캐시까지 컴퓨터 시스템 전반에서 쓰임 브라우저 캐시: 웹페이지, 이미지, 스크립트 등을 로컬에 저장 CPU 캐시: 자주 쓰는 데이터를 RAM보다 빠른 캐시 메모리에 보관 데이터베이스 캐시: 반복되는 결과를 메모리에 저장 ex Redis CDN: 콘텐츠를 전 세계 서버에 분산 저장해 가까운 곳에서 제공 \b캐싱이 필요한 이유 지역성의 원리 기반: 시간 지역성: 방금 쓴 데이터는 곧 다시 쓸 가능성이 높음. 공간 지역성: 특정 데이터 근처 데이터도 함께 참조될 가능성이 큼. 성능 향상: 네트워크 요청이나 DB 조회는 밀리초 단위로 느리지만, 메모리 캐시는 나노초 수준으로 상대적으로 빠르게 접근 가능. 비용 절감: 서버 부하와 네트워크 트래픽을 줄여 비용을 낮춘다. 장점과 단점 장점 응답 속도 향상을 통한 사용자 체감 성능 개선. 원본 저장소(DB, API, 디스크, 네트워크)의 부하 감소 및 비용 절감. 단점 캐시와 원본 데이터 간 불일치(스테일 데이터) 문제. 추가 메모리 사용, 캐시 구축·무효화 전략 설계 복잡도 증가 캐시 위치에 따른 캐싱 종류: 메모리 캐싱과 디스크 캐싱 메모리 캐싱 저장 위치: RAM 휘발성: 앱이 종료되면 사라짐. 용량: RAM의 용량이 제한적이라 많이 저장 못함. 디스크 캐싱 저장 위치: 저장소 영구성: 앱을 종료해도 유지됨. 용량: 메모리(RAM)에 비해 저장을 훨씬 더 많이할 수 있음. Apple 플랫폼 개발에서의 캐싱 대상 이미지 일반 데이터 구조화된 데이터 네트워크 응답 등등 Apple Platforms 개발에서 캐싱 계층 예시 메모리 캐시(NSCache): 앱 실행 중 빠른 접근용, 메모리 부족시 자동 제거. 디스크 캐시(FileManager): 앱 재시작해도 유지, 영속성 보장. 네트워크 캐시: HTTP 응답 자체를 캐싱. 캐싱을 위한 도구, 방법들 NSCache 설명 Apple Platform에서 메모리 기반 캐싱을 위한 Foundation 프레임워크 클래스 이미지, API 응답 등 자주 쓰이는 데이터를 메모리에 임시 저장 재계산 비용을 줄이며 시스템 압박시 자동으로 항목 제거 특징 자동 메모리 관리 Thread-safe 다중 스레드 환경에서 lock 없이 안전하게 접근/수정 가능 GCD와 잘 맞음 키 복사 안함 NSMutableDictionary와 달리 key 객체를 복사하지 않아 메모리 효율적. NSString이나 AnyObject로 키사용 Dictionary [swift-dictionary] 참고 FileManager 디스크 캐시 UserDefault CoreData SwiftData URLCache King fisher (3rd Party) SDWebImage (3rd Party) 캐시 메모리 캐싱 vs 메모리 캐싱 vs 디스크 캐싱 빠름\t│ ┌─────────────▼─────────────┐ │ CPU 캐시 메모리 캐싱 │ ← CPU가 RAM 데이터 캐싱 │ (L1 / L2 / L3) │ └─────────────┬─────────────┘ │ ┌─────────────▼─────────────┐ │ 메모리 캐싱 │ ← RAM에 저장장치 데이터 캐싱 │ (NSCache, 이미지 캐시) │ └─────────────┬─────────────┘ │ ┌─────────────▼─────────────┐ │ 디스크 캐싱 │ ← 저장장치에 네트워크 데이터 캐싱 │ (URLCache, 파일 캐시) │ └─────────────┴─────────────┘ │ 느림 ","permalink":"http://yeniful.github.io/posts/2026/apple-caching/","summary":"iOS ViewController의 생명주기 메서드와 Push/Pop, Present/Dismiss 상황별 호출 순서를 정리합니다.","title":"[Apple Platforms] Apple 플랫폼 개발에서의 캐싱 (Caching)  🖋️"},{"content":"ViewController의 생명 주기란? ViewController의 생명 주기(Life Cycle)란 화면이 생성되고 사라지기까지의 과정을 말합니다. iOS는 이 과정의 특정 시점에 메서드를 호출하여 개발자가 적절한 작업을 수행할 수 있도록 합니다.\n생명 주기 메서드 viewDidLoad : 뷰가 메모리에 로드될 때 (1회) viewWillAppear : 화면에 나타나기 직전 (매번) viewDidAppear : 화면에 나타난 후 (매번) viewWillDisappear : 화면에서 사라지기 직전 (매번) viewDidDisappear : 화면에서 사라진 후 (매번) 사용 예시 override func viewDidLoad() { super.viewDidLoad() fetchUserData() // 이 곳에서 API 호출시 최초 1번만 데이터를 가지고 옵니다. } override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) fetchUserData() // 이 곳에서 API 호출시 화면 돌아올 때마다 최신 데이터로 새로고침 합니다. } Cases Case 1 : Push \u0026amp; Pop 질문 A화면에서 B화면을 Push했다가 Pop해서 다시 A로 돌아올 때 A에 대해 어떤 생명 주기 메서드들이 호출될까요? 답변\nviewDidLoad를 제외한 메서드들. A-\u0026gt;B 이동을 위해 B를 푸시할 때 A는 화면에서는 사라지지만, Navigation Stack에 남아 A가 여전히 존재하기 때문입니다. Push 과정\nA: viewWillDisappear B: viewDidLoad (최초 1회) B: viewWillAppear (애니메이션 진행) B: viewDidAppear A: viewDidDisappear Pop 과정\nB: viewWillDisappear A: viewWillAppear (애니메이션 진행) A: viewDidAppear B: viewDidDisappear Case 2 : Present (Modal) \u0026amp; Dismiss 질문 A화면에서 B화면을 present했다가 dismiss한 경우 A 화면의 viewWillAppear가 호출될까요?\n답변\n화면이 완전히 가려지는 경우 호출되고, 뒤에 일부가 보이는 경우 호출되지 않습니다. iOS 13 이후 modalPresentationStyle의 기본값이 .automatic(대부분 .pageSheet)으로 변경되어, 별도 설정 없이 present하면 viewWillAppear가 호출되지 않습니다. 🆗 호출되는 경우:\n.fullScreen Present 과정\nA: viewWillDisappear B: viewDidLoad (최초 1회) B: viewWillAppear B: viewDidAppear A: viewDidDisappear Dismiss 과정\nB: viewWillDisappear A: viewWillAppear A: viewDidAppear B: viewDidDisappear ❌ 호출되지 않는 경우:\n.pageSheet (기존의 .automatic, 거의 .fullScreen과 유사하지만 상단 살짝 보임) .formSheet (iPhone에서는 .pageSheet과 동일하게 보이지만, iPad에서는 더 작게 보임) Present 과정\nA: viewWillDisappear ❌ 호출 안 됨 A: viewDidDisappear ❌ 호출 안 됨 B: viewWillAppear ✅ B: viewDidAppear ✅ Dismiss 과정\nB: viewWillDisappear ✅ B: viewDidDisappear ✅ A: viewWillAppear ❌ 호출 안 됨 A: viewDidAppear ❌ 호출 안 됨 Case 3 : .pageSheet가 적용된 B를 dismiss하고나서 A화면의 데이터를 새로고침 하는 방법들 .fullScreen 사용 Delegate로 전달 NotificationCenter 사용 Closure (Completion Handler) 사용 활용 viewDidLoad에서 초기 설정(UI 구성, constraint 설정)을 하고, viewWillAppear에서 최신 데이터를 가져오는 로직을 다룹니다. viewWillAppear에서 무거운 작업 시 버벅임이 발생할 수 있으므로 비동기 처리를 해야 합니다. // ❌ 지양 override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) let data = fetchHugeDataSynchronously() // 동기 작업 → 버벅임 tableView.reloadData() } // ✅ 권장 override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) Task { let data = await fetchData() // 비동기 처리 tableView.reloadData() } } ","permalink":"http://yeniful.github.io/posts/2026/uikit-view-controller-life-cycle/","summary":"iOS ViewController의 생명주기 메서드와 Push/Pop, Present/Dismiss 상황별 호출 순서를 정리합니다.","title":"[UIKit] ViewController 생명주기 (View Controller Life Cycle)"},{"content":"Overview 앱 생명주기: 앱이 실행되는 시점부터 종료되는 시점까지 거치는 여러 상태의 순환 과정 iOS 앱의 5가지 상태 Not Running (실행되지 않음) Inactive (비활성) Active (활성) Background (백그라운드) Suspended (일시 중지) SwiftUI에서의 앱 생명주기 SwiftUI에서 앱은 @main attribute로 표시된 구조체에서 시작. UIApplicationMain의 대체 @main struct MyApp: App { var body: some Scene { WindowGroup { ContentView() } } } ","permalink":"http://yeniful.github.io/posts/2026/apple-app-life-cycle/","summary":"\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e앱 생명주기: 앱이 실행되는 시점부터 종료되는 시점까지 거치는 여러 상태의 순환 과정\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"ios-앱의-5가지-상태\"\u003eiOS 앱의 5가지 상태\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eNot Running (실행되지 않음)\u003c/li\u003e\n\u003cli\u003eInactive (비활성)\u003c/li\u003e\n\u003cli\u003eActive (활성)\u003c/li\u003e\n\u003cli\u003eBackground (백그라운드)\u003c/li\u003e\n\u003cli\u003eSuspended (일시 중지)\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"swiftui에서의-앱-생명주기\"\u003eSwiftUI에서의 앱 생명주기\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSwiftUI에서 앱은 \u003ccode\u003e@main\u003c/code\u003e attribute로 표시된 구조체에서 시작.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eUIApplicationMain\u003c/code\u003e의 대체\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-Swift\" data-lang=\"Swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e@main\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMyApp\u003c/span\u003e: App {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e body: some Scene {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        WindowGroup {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            ContentView()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"[Apple Platforms] 앱 생명 주기 (App Life Cycle)  🖋️"},{"content":"Motivation 클로저 안의 weak self Overview self: 클래스 인스턴스 참조 약한 참조 ARC Note 일반적으로 클로저는 클로저 내부에서 변수를 사용할 때 암시적으로 변수를 캡처하지만, 이 경우에는 명시적으로 작성해야 합니다. self를 캡처하려면, 사용할 때 명시적으로 self를 작성하거나, 클로저의 캡처 리스트에 self를 포함합니다. self를 명시적으로 작성하는 것은 의도를 분명하게 표현하고, 참조 순환이 없음을 확인하도록 유도하는 역할도 합니다 Capture Values 클로저는 정의된 주변 컨텍스트로부터 상수와 변수를 캡처할 수 있음. 상수와 변수를 정의한 원래 범위가 더이상 존재하지 않더라도 본문 내에서 상수와 변수의 값을 참조하고 수정할 수 있음. 값을 캡처할 수 있는 가장 간단한 클로저 형태는 다른 함수의 본문 내에 작성하는 중첩 함수 중첩 함수는 바깥 함수의 어떠한 인자도 캡처할 수 있고 바깥 함수 내에 정의된 상수와 변수를 캡처할 수도 있습니다. References 👀 Swift Programming Language - 탈출 클로저 ","permalink":"http://yeniful.github.io/posts/2026/swift-weak-self/","summary":"\u003ch2 id=\"motivation\"\u003eMotivation\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e클로저 안의 weak self\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eself: 클래스 인스턴스 참조\u003c/li\u003e\n\u003cli\u003e약한 참조\u003c/li\u003e\n\u003cli\u003eARC\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"note\"\u003eNote\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e일반적으로 클로저는 클로저 내부에서 변수를 사용할 때 암시적으로 변수를 캡처하지만, 이 경우에는 명시적으로 작성해야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eself\u003c/code\u003e를 캡처하려면, 사용할 때 명시적으로 \u003ccode\u003eself\u003c/code\u003e를 작성하거나, 클로저의 캡처 리스트에 \u003ccode\u003eself\u003c/code\u003e를 포함합니다. \u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eself\u003c/code\u003e를 명시적으로 작성하는 것은 의도를 분명하게 표현하고, 참조 순환이 없음을 확인하도록 유도하는 역할도 합니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"capture-values\"\u003eCapture Values\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e클로저는 정의된 주변 컨텍스트로부터 상수와 변수를 캡처할 수 있음.\u003c/li\u003e\n\u003cli\u003e상수와 변수를 정의한 원래 범위가 더이상 존재하지 않더라도 본문 내에서 상수와 변수의 값을 참조하고 수정할 수 있음.\u003c/li\u003e\n\u003cli\u003e값을 캡처할 수 있는 가장 간단한 클로저 형태는 다른 함수의 본문 내에 작성하는 중첩 함수\n\u003cul\u003e\n\u003cli\u003e중첩 함수는 바깥 함수의 어떠한 인자도 캡처할 수 있고 바깥 함수 내에 정의된 상수와 변수를 캡처할 수도 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"references-\"\u003eReferences 👀\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://bbiguduk.github.io/swift-book-korean/documentation/the-swift-programming-language-korean/closures/#%ED%83%88%EC%B6%9C-%ED%81%B4%EB%A1%9C%EC%A0%80-Escaping-Closures\"\u003eSwift Programming Language - 탈출 클로저\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"[Swift] weak self 🖋️"},{"content":"설명 Key-Value 저장하는 컬렉션 타입 해시 테이블로 구현되어있음 빠른 속도로 접근, 수정, 추가, 키 존재 여부 확인 가능 O(1) let scores = [\u0026#34;\broy\u0026#34;: 95, \u0026#34;gucci\u0026#34;: 82, \u0026#34;yeni\u0026#34;: 90] // 모두 O(1) 시간 let royScore = scores[\u0026#34;roy\u0026#34;] // 95 let gucciScore = scores[\u0026#34;gucci\u0026#34;] // 82 scores[\u0026#34;terry\u0026#34;] = 75 // 추가 유의 제거시 O(n)의 가능성 값 제거 (removeValue(forKey: key))의 경우 기술적으로는 O(1)로 구현되어 있음 하지만 Copy-On-Write 최적화 때문에 O(n) 복잡도를 가질 수 있음. // 첫 번째 Dictionary var dict1 = [\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 3] // dict2는 dict1과 메모리를 공유 (Copy-on-Write) var dict2 = dict1 // 이 제거 연산은 dict1을 수정하기 전에 전체 복사가 필요할 수 있음 (O(n)) dict1.removeValue(forKey: \u0026#34;a\u0026#34;) 활용 Key 존재 확인 // 👍 O(1) : 직접 접근해서 확인 if dict[\u0026#34;key\u0026#34;] != nil { ... } // 😱 O(n) : 배열로 변환 후 순회하기 때문에 비효율적이다. if dict.keys.contains(\u0026#34;yeni\u0026#34;) { ... } Value 조회 // 👍 O(1) : 해시 기반 직접 조회 let value = scores[\u0026#34;yeni\u0026#34;] // 🤩 값이 없을 수도 있으므로 Optional 처리가 필요하다. if let score = scores[\u0026#34;yeni\u0026#34;] { print(\u0026#34;Alice\u0026#39;s score: \\(score)\u0026#34;) } ","permalink":"http://yeniful.github.io/posts/2026/swift-dictionary/","summary":"\u003ch2 id=\"설명\"\u003e설명\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eKey-Value 저장하는 컬렉션 타입\u003c/li\u003e\n\u003cli\u003e해시 테이블로 구현되어있음\n\u003cul\u003e\n\u003cli\u003e빠른 속도로 접근, 수정, 추가, 키 존재 여부 확인 가능 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elet scores = [\u0026#34;\broy\u0026#34;: 95, \u0026#34;gucci\u0026#34;: 82, \u0026#34;yeni\u0026#34;: 90]\n\n// 모두 O(1) 시간\nlet royScore = scores[\u0026#34;roy\u0026#34;]           // 95\nlet gucciScore = scores[\u0026#34;gucci\u0026#34;]       // 82\nscores[\u0026#34;terry\u0026#34;] = 75                    // 추가\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"유의\"\u003e유의\u003c/h2\u003e\n\u003ch3 id=\"제거시-on의-가능성\"\u003e제거시 O(n)의 가능성\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e값 제거 (removeValue(forKey: key))의 경우 기술적으로는 O(1)로 구현되어 있음\u003c/li\u003e\n\u003cli\u003e하지만 Copy-On-Write 최적화 때문에 O(n) 복잡도를 가질 수 있음.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 첫 번째 Dictionary\nvar dict1 = [\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 3]\n\n// dict2는 dict1과 메모리를 공유 (Copy-on-Write)\nvar dict2 = dict1\n\n// 이 제거 연산은 dict1을 수정하기 전에 전체 복사가 필요할 수 있음 (O(n))\ndict1.removeValue(forKey: \u0026#34;a\u0026#34;)\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"활용\"\u003e활용\u003c/h2\u003e\n\u003ch3 id=\"key-존재-확인\"\u003eKey 존재 확인\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 👍 O(1) : 직접 접근해서 확인\nif dict[\u0026#34;key\u0026#34;] != nil { ... }\n\n// 😱 O(n) : 배열로 변환 후 순회하기 때문에 비효율적이다.\nif dict.keys.contains(\u0026#34;yeni\u0026#34;) { ... }\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"value-조회\"\u003eValue 조회\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 👍 O(1) : 해시 기반 직접 조회\nlet value = scores[\u0026#34;yeni\u0026#34;]\n\n// 🤩 값이 없을 수도 있으므로 Optional 처리가 필요하다.\nif let score = scores[\u0026#34;yeni\u0026#34;] {\n    print(\u0026#34;Alice\u0026#39;s score: \\(score)\u0026#34;)\n}\n\u003c/code\u003e\u003c/pre\u003e","title":"[Swift] 딕셔너리 (Dictionary)  🖋️"},{"content":"Motivation iOS 13+ 씬 기반 UIKit 프로젝트는 AppDelegate와 SceneDelegate가 함께 생성된다. Storyboard를 쓰는 기본 템플릿에서는 시스템이 UIWindow를 생성/연결한다. Programmatic UI를 쓰면 scene(_:willConnectTo:)에서 UIWindow를 직접 구성해야 한다. SceneDelegate의 역할은 무엇일까? Overview AppDelegate는 프로세스 수준 이벤트와 Scene session 생성/폐기를 관리한다. SceneDelegate는 각 Scene의 UI 생명주기와 UI 설정을 관리한다. iOS 12까지 AppDelegate가 UI 생명주기까지 담당했지만, iOS 13부터 하나의 앱이 여러 UI 인스턴스(Scene)를 가질 수 있게 되면서 역할이 분리되었다. 씬 기반 라이프사이클을 채택하면 UIApplicationDelegate의 UI 관련 콜백은 호출되지 않고, SceneDelegate 메서드가 1:1로 대응된다. 이 글에서는 SceneDelegate의 역할과 각 메서드의 동작 원리를 알아본다. SceneDelegate란? iOS 13부터 도입된 앱의 화면(UI) 생명주기를 관리하는 객체. AppDelegate에서 UI 상태 관리 역할이 분리되어 나왔다. 도입 배경 WWDC 2019에서 iOS 13 / iPadOS 13의 Scene 기반 라이프사이클과 iPad 멀티 윈도우가 소개되었다. 멀티 윈도우를 지원하려면 각 화면 인스턴스(Scene)마다 독립적인 UI 생명주기 관리가 필요했다. 기존 AppDelegate 구조의 한계 (WWDC19 Session 258) \u0026ldquo;In iOS 12 and earlier, your application had one process and also just one user interface instance to match it.\u0026rdquo; \u0026ldquo;Applications now still share one process but may have multiple user interface instances or scene sessions.\u0026rdquo;\niOS 12 이전: AppDelegate의 didEnterForeground, willResignActive 등의 메서드는 앱 전체에 대해 한 번만 호출됨 iOS 13 이후: 같은 앱의 창이 여러 개 열려있으면, 각 창이 독립적으로 foreground/background 전환을 해야 함 한계: AppDelegate 하나로는 \u0026ldquo;어떤 UI가 foreground로 왔는지\u0026rdquo; 구분할 수 없음 해결: UI 생명주기 관리를 Scene 단위로 분리 → SceneDelegate 도입 iOS 12 이전 iOS 13 이후 구조 1 App = 1 Process = 1 UI 1 App = 1 Process = 여러 UI(Scene) AppDelegate 프로세스 생명주기, UI 상태 모두 관리 프로세스 생명주기 + Scene session 생성/폐기 관리 SceneDelegate 없음 각 Scene의 UI 생명주기 + UI 설정/복원 참고: iOS 9의 Split View는 다른 앱을 나란히 보는 것이고, iOS 13의 멀티 윈도우는 같은 앱의 여러 인스턴스를 동시에 보는 것이다.\nScene 관련 클래스 구조 UISceneSession ──────── UIScene ◀── UIWindowScene │ │ │ .scene 프로퍼티로 참조 │ .windows 프로퍼티로 관리 │ ▼ │ UIWindow │ │ └─ 메타정보/상태 관리 ▼ (state restoration 등) rootViewController 클래스 역할 UISceneSession Scene의 세션 메타정보를 담고, 시스템이 세션을 추적/유지한다. UIScene 앱 UI의 하나의 인스턴스를 나타내는 추상 클래스. UIWindowScene UIScene의 구체적인 서브클래스. UIWindow를 표시할 환경을 제공한다. UIWindow 앱의 UI를 담는 컨테이너. rootViewController를 통해 화면에 뷰를 표시한다. SceneDelegate는 UIWindowSceneDelegate 프로토콜을 채택하여 UIWindowScene의 생명주기 이벤트를 처리한다.\nScene ≠ Window Scene과 Window는 다른 개념이다. Scene은 앱 UI 인스턴스(세션)이고, Window는 화면에 그려지는 컨테이너다. 멀티 윈도우(iPadOS)는 같은 앱의 여러 Scene을 동시에 보여주는 것에 가깝다. 보통 1 Scene = 1 `UIWindow 구성으로 사용하는 경우가 많다. Scene Configuration (Info.plist / 코드) 시스템은 새 Scene을 만들기 전에 application(_:configurationForConnecting:options:)를 호출해 어떤 Scene 구성을 쓸지 묻는다. 이 구성에는 SceneDelegate 클래스, Storyboard 이름, (선택적으로) Scene 서브클래스가 포함된다. 구성은 Info.plist에 정적으로 선언하거나 런타임에 동적으로 생성할 수 있다. options에는 user activity, URL context 등이 포함되어 어떤 Scene을 열지 결정하는 힌트를 제공한다. SceneDelegate 메서드 프로젝트를 생성했을 때 SceneDelegate.swift 파일 구성은 다음과 같다. import UIKit class SceneDelegate: UIResponder, UIWindowSceneDelegate { var window: UIWindow? func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) { guard let _ = (scene as? UIWindowScene) else { return } } func sceneDidDisconnect(_ scene: UIScene) { ... } func sceneDidBecomeActive(_ scene: UIScene) { ... } func sceneWillResignActive(_ scene: UIScene) { ... } func sceneWillEnterForeground(_ scene: UIScene) { ... } func sceneDidEnterBackground(_ scene: UIScene) { ... } } 각 메서드의 기본 주석들을 함께 읽어보자 func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) - Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`. - If using a storyboard, the `window` property will automatically be initialized and attached to the scene. - This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead). scene() 메서드를 통해 UIWindow를 설정하고 UIWindowScene에 연결하세요. Storyboard를 사용하면 window 프로퍼티가 자동으로 초기화되고 scene에 연결됩니다. 이 delegate가 호출된다고 해서 연결되는 scene이나 session이 새로운 것은 아닙니다. scene이 앱에 연결될 때 호출된다. Programmatic UI를 사용하면 이 메서드에서 UIWindow를 직접 생성하고 rootViewController를 설정해야 한다.\nfunc sceneDidDisconnect(_ scene: UIScene) - Called as the scene is being released by the system. - This occurs shortly after the scene enters the background, or when its session is discarded. - Release any resources associated with this scene that can be re-created the next time the scene connects. - The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead). sceneDidDisconnect()는 시스템이 scene을 해제할 때 호출됩니다. 백그라운드 진입 직후일 수도 있지만, 시스템이 필요할 때 언제든 호출될 수 있습니다. 다음에 scene이 다시 연결될 때 재생성할 수 있는 리소스를 해제하세요. scene이 나중에 다시 연결될 수 있습니다. 세션이 반드시 삭제되는 것은 아닙니다. 시스템이 리소스를 회수하기 위해 scene을 해제할 때 호출될 수 있다. 완전히 종료된 것이 아니므로, 나중에 다시 연결될 수 있다.\nfunc sceneDidBecomeActive(_ scene: UIScene) - Called when the scene has moved from an inactive state to an active state. - Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive. scene이 비활성 상태에서 활성 상태로 전환될 때 호출됩니다. scene이 비활성 상태일 때 일시 중지되었거나 아직 시작되지 않은 작업을 재시작하세요. func sceneWillResignActive(_ scene: UIScene) - Called when the scene will move from an active state to an inactive state. - This may occur due to temporary interruptions (ex. an incoming phone call). scene이 활성 상태에서 비활성 상태로 전환될 때 호출됩니다. 일시적인 중단(예: 전화 수신)으로 인해 발생할 수 있습니다. func sceneWillEnterForeground(_ scene: UIScene) - Called as the scene transitions from the background to the foreground. - Use this method to undo the changes made on entering the background. scene이 백그라운드에서 포그라운드로 전환될 때 호출됩니다. 이 메서드를 통해 백그라운드 진입 시 만든 변경사항을 되돌리세요. sceneDidEnterBackground(_ scene: UIScene) - Called as the scene transitions from the foreground to the background. - Use this method to save data, release shared resources, and store enough scene-specific state information to restore the scene back to its current state. scene이 포그라운드에서 백그라운드로 전환될 때 호출됩니다. 이 메서드를 통해 다음의 작업을 하세요. 데이터 저장 공유 리소스 해제 scene을 현재 상태로 복구하기에 충분한 씬별 상태 정보를 저장. Scene 생명주기 흐름 ┌─────────────────────────────────────┐ │ App Launch │ └─────────────────┬───────────────────┘ ▼ ┌─────────────────────────────────────┐ │ scene(_:willConnectTo:options:) │ │ Scene 연결 │ └─────────────────┬───────────────────┘ ▼ ┌─────────────────────────────────────┐ │ sceneWillEnterForeground(_:) │ │ 포그라운드 진입 예정 │ └─────────────────┬───────────────────┘ ▼ ┌─────────────────────────────────────────────────────────┐ │ sceneDidBecomeActive(_:) │ │ 활성 상태 전환 │ └───────────────────────────┬─────────────────────────────┘ │ ┌───────────┴───────────┐ ▼ ▼ ┌──────────────────────────┐ ┌──────────────────────────┐ │ sceneWillResignActive(_:)│ │ (사용자가 앱 사용 중) │ │ 비활성 상태 전환 예정 │ │ │ └────────────┬─────────────┘ └──────────────────────────┘ ▼ ┌──────────────────────────┐ │ sceneDidEnterBackground │ │ 백그라운드 진입 │ └────────────┬─────────────┘ ▼ ┌──────────────────────────┐ │ sceneDidDisconnect(_:) │ │ 시스템이 Scene 해제 │ └──────────────────────────┘ 참고: sceneWillEnterForeground는 정의상 백그라운드 → 포그라운드 전환 시 호출된다. 첫 연결 직후 이어지는 흐름에서도 호출될 수 있지만, 공식 의미는 “foreground 진입”이다.\n참고: sceneDidDisconnect는 백그라운드 진입 직후뿐 아니라 언제든 호출될 수 있으며, 항상 발생하는 단계는 아니다.\n메서드 활용 예시 메서드 활용 예시 scene(_:willConnectTo:options:) UIWindow 생성, rootViewController 설정 sceneDidDisconnect(_:) 재생성 가능한 리소스 해제, 캐시 정리 sceneDidBecomeActive(_:) 타이머 재시작, 애니메이션 재개, 데이터 새로고침 sceneWillResignActive(_:) 게임 일시정지, 타이머 중지, 진행 중인 작업 저장 sceneWillEnterForeground(_:) 블러 처리 제거, UI 새로고침 sceneDidEnterBackground(_:) 민감한 정보 블러 처리, 데이터 저장, 상태 정보 저장 Storyboard 대신 Programmatic UI 구현하기 Storyboard를 사용하지 않고, 코드를 통한 Programmatic UI 를 구현하려면 먼저 Storyboard가 연결된 값들을 없애주어야 한다. Info.plist의 Scene Configuration에서 Storyboard Name을 제거한다. ![[Screenshot 2026-01-22 at 18.11.26.png]] SceneDelegate의 가장 첫번 째 메서드인 func scene()을 다음과 같이 수정해준다. var window: UIWindow? func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) { guard let windowScene = (scene as? UIWindowScene) else { return } let window = UIWindow(windowScene: windowScene) // 객체 생성 window.rootViewController = ViewController() window.makeKeyAndVisible() self.window = window // 생성 후나중에 할당 } 주로 아래의 방식으로 할당했었는데, 위처럼 객체를 완성하고 나중에 할당하는 패턴이 Swift에서 권장되는 패턴이라고 한다. guard let windowScene = (scene as? UIWindowScene) else { return } window = UIWindow(windowScene: windowScene) window?.rootViewController = ViewController() window?.makeKeyAndVisible() 추가 설명\nScene Configuration에 storyboard가 지정되어 있으면, 시스템이 해당 storyboard로 window를 생성/연결한다. Info.plist / Scene Configuration / Storyboard Name 값에서 시작 스토리보드를 지정해줄 수 있다. 기본 템플릿에서는 ViewController가 초기 루트로 설정되어 있다. Q\u0026amp;A Q: iOS 13 미만을 지원하려면 SceneDelegate를 어떻게 처리해야 할까? @available(iOS 13.0, *) 어노테이션을 SceneDelegate 클래스에 추가한다. AppDelegate에서 window 프로퍼티를 선언하고, iOS 12 이하에서는 AppDelegate에서 UI를 설정한다. 백포트 시 AppDelegate/SceneDelegate를 둘 다 두면 UIKit이 런타임에 올바른 쪽을 호출한다. Q: sceneDidDisconnect와 앱 종료는 같은 건가? 아니다. sceneDidDisconnect는 시스템이 Scene을 해제할 때 호출된다. 백그라운드 직후뿐 아니라 언제든 호출될 수 있다. Scene의 세션(UISceneSession)은 유지될 수 있으며, 사용자가 다시 앱으로 돌아오면 Scene이 재연결될 수 있다. 세션이 영구 폐기되면 AppDelegate의 application(_:didDiscardSceneSessions:)에서 정리한다. 이 콜백은 다음 실행 직후 호출될 수도 있다. Q: Foreground/Background와 Active/Inactive의 차이는? Foreground/Background: 앱이 화면에 보이는지 여부 Foreground: 화면에 보임 Background: 화면에 안 보임 Active/Inactive: 앱이 이벤트를 받을 수 있는지 여부 Active: 터치 이벤트 등을 받을 수 있음 Inactive: 화면에 보이지만 이벤트를 받지 못함 (예: 전화 수신, 제어 센터 열기) Q: 왜 scene(_:willConnectTo:)에서 guard let으로 UIWindowScene을 캐스팅할까? scene 파라미터의 타입은 UIScene(추상 클래스)이다. UIWindow를 생성하려면 구체적인 서브클래스인 UIWindowScene이 필요하다. 다운캐스팅에 실패하면 윈도우를 만들 수 없으므로 early return 한다. Q: AppDelegate의 application(_:didFinishLaunchingWithOptions:)는 언제 호출되나? iOS 13 이후에도 여전히 호출된다. 앱 프로세스가 시작될 때 가장 먼저 호출되며, Scene 구성/연결보다 먼저 실행된다. 앱 전체에서 공유하는 초기 설정(Firebase, 로깅 등)은 여기서 하면 된다. Q: iPhone(iOS)에서는 여러 Scene을 사용하지 않는 건가? iOS에서는 일반적으로 하나의 Scene을 설계하고, iPadOS/macOS에서는 여러 Scene을 고려한다. 하지만 SceneDelegate 구조가 iPhone에서도 기본 템플릿으로 제공되는 이유: iPad와 코드를 공유할 때 유리함 향후 확장성과 코드 일관성을 위해 Q: SwiftUI는 SceneDelegate를 어떻게 처리할까? SwiftUI는 SceneDelegate를 직접 사용하지 않는다. 대신 App 프로토콜과 Scene 프로토콜로 추상화되어 있다. @main struct MyApp: App { var body: some Scene { WindowGroup { ContentView() } } } WindowGroup은 SwiftUI가 제공하는 대표적인 Scene 컨테이너다. 생명주기 이벤트는 scenePhase 환경 변수로 감지할 수 있다. @Environment(\\.scenePhase) var scenePhase var body: some View { ContentView() .onChange(of: scenePhase) { phase in switch phase { case .active: // sceneDidBecomeActive case .inactive: // sceneWillResignActive case .background: // sceneDidEnterBackground } } } AppDelegate나 SceneDelegate가 필요하면 @UIApplicationDelegateAdaptor를 사용할 수 있다. 참고 (공식) WWDC19: Architecting Your App for Multiple Windows (Video)\nhttps://developer.apple.com/videos/play/wwdc2019/258/ WWDC19: Architecting Your App for Multiple Windows (Slides PDF)\nhttps://devstreaming-cdn.apple.com/videos/wwdc/2019/258ggtahutefvsda35yt/258/258_architecting_your_app_for_multiple_windows.pdf UIApplicationDelegate (Scene configuration / discard sessions)\nhttps://developer.apple.com/documentation/uikit/uiapplicationdelegate UISceneDelegate (Scene lifecycle)\nhttps://developer.apple.com/documentation/uikit/uiscenedelegate SwiftUI Tutorial: Responding to events (Scene architecture / scenePhase)\nhttps://developer.apple.com/tutorials/app-dev-training/responding-to-events ","permalink":"http://yeniful.github.io/posts/2026/uikit-scene-delegate/","summary":"iOS 13부터 도입된 SceneDelegate의 역할, 도입 배경, 각 메서드의 동작 원리 알아보기.","title":"[UIKit] Scene Delegate"},{"content":"문제 탐색 문제 : 유기농 배추 접근 : DFS/BFS 코드 설계 Input (배추들의 위치) Adjacency Matrix (2차원 배열)에 표시 방문한 위치를 visited 2차원 배열에 표시 (0, 0)부터 배추가 있는지, 이미 방문했던 좌표 (이미 방문했던 배추 그룹) 인지를 판별하고 배추가 있고, 새로 방문한 곳이라면 인접한 배추들을 BFS로 방문. 방문한 위치를 visited에 표시 인접한 배추를 다 방문했다면 탐색 종료. 새로운 배추 그룹을 찾는다. 해당 그룹의 start 지점을 발견하면 지렁이를 한 마리 추가한다. 구현 import java.io.*; import java.util.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int T = Integer.parseInt(br.readLine()); StringTokenizer st; while(T-- \u0026gt; 0){ // Input st = new StringTokenizer(br.readLine()); int M = Integer.parseInt(st.nextToken()); int N = Integer.parseInt(st.nextToken()); int K = Integer.parseInt(st.nextToken()); boolean[][] g = new boolean[M][N]; boolean[][] visited = new boolean[M][N]; while(K-- \u0026gt; 0){ st = new StringTokenizer(br.readLine()); int x = Integer.parseInt(st.nextToken()); int y = Integer.parseInt(st.nextToken()); g[x][y] = true; } // Traversal int result = 0; int[] dx = new int[] { 0, 1, 0, -1}; int[] dy = new int[] { 1, 0, -1, 0}; for(int i = 0; i \u0026lt; M; i++){ for(int j = 0; j \u0026lt; N; j++){ // 시작 점 if(g[i][j] == false || visited[i][j]) continue; else result++; // BFS 시작 Queue\u0026lt;int[]\u0026gt; q = new ArrayDeque\u0026lt;\u0026gt;(); q.add(new int[] {i, j}); visited[i][j] = true; // 시작점 방문 while(!q.isEmpty()){ int[] current = q.poll(); for(int dir = 0; dir \u0026lt; 4; dir++){ int currentX = current[0] + dx[dir]; int currentY = current[1] + dy[dir]; if(currentX \u0026lt; 0 || currentY \u0026lt; 0 || currentX \u0026gt;= M || currentY \u0026gt;= N) continue; if(!g[currentX][currentY] || visited[currentX][currentY]) continue; visited[currentX][currentY] = true; // enque할 때 visited q.add(new int[] {currentX, currentY}); } } } } System.out.println(result); } } } 배움 12%에서 메모리 초과가 났었다. 새 좌표에 방문하는 시점 (디큐할 때 (poll)) 에 visited 처리해주고 있었는데 중복 enque가 발생했었다. 동일한 좌표가 큐에 여러번 들어가면 최악의 경우 N번 이상 중복 방문하게 된다. 이러한 이유로 중복 인큐를 방지하기 위해 큐에서 꺼낸 시점이 아닌, 큐에 넣기 전에 visited[currentX][currentY] = true로 수정했다. 👀 다른 사람의 DFS 풀이 https://chaerim1001.tistory.com/97 ","permalink":"http://yeniful.github.io/posts/2025/20250930_boj/","summary":"\u003ch2 id=\"문제-탐색\"\u003e문제 탐색\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e문제 : \u003ca href=\"https://www.acmicpc.net/problem/1012\"\u003e유기농 배추\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e접근 : DFS/BFS\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"코드-설계\"\u003e코드 설계\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eInput (배추들의 위치) Adjacency Matrix (2차원 배열)에 표시\u003c/li\u003e\n\u003cli\u003e방문한 위치를 visited 2차원 배열에 표시\u003c/li\u003e\n\u003cli\u003e(0, 0)부터 배추가 있는지, 이미 방문했던 좌표 (이미 방문했던 배추 그룹) 인지를 판별하고\n\u003cul\u003e\n\u003cli\u003e배추가 있고, 새로 방문한 곳이라면 인접한 배추들을 BFS로 방문.\u003c/li\u003e\n\u003cli\u003e방문한 위치를 visited에 표시\u003c/li\u003e\n\u003cli\u003e인접한 배추를 다 방문했다면 탐색 종료.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e새로운 배추 그룹을 찾는다.\n\u003cul\u003e\n\u003cli\u003e해당 그룹의 start 지점을 발견하면 지렁이를 한 마리 추가한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"구현\"\u003e구현\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-Java\" data-lang=\"Java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e java.io.*;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e java.util.*;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMain\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e(String\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e args) \u003cspan style=\"color:#66d9ef\"\u003ethrows\u003c/span\u003e IOException {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        BufferedReader br \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e BufferedReader(\u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e InputStreamReader(System.\u003cspan style=\"color:#a6e22e\"\u003ein\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e T \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Integer.\u003cspan style=\"color:#a6e22e\"\u003eparseInt\u003c/span\u003e(br.\u003cspan style=\"color:#a6e22e\"\u003ereadLine\u003c/span\u003e());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        StringTokenizer st;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e(T\u003cspan style=\"color:#f92672\"\u003e--\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e 0){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e// Input\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            st \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e StringTokenizer(br.\u003cspan style=\"color:#a6e22e\"\u003ereadLine\u003c/span\u003e());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e M \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Integer.\u003cspan style=\"color:#a6e22e\"\u003eparseInt\u003c/span\u003e(st.\u003cspan style=\"color:#a6e22e\"\u003enextToken\u003c/span\u003e());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e N \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Integer.\u003cspan style=\"color:#a6e22e\"\u003eparseInt\u003c/span\u003e(st.\u003cspan style=\"color:#a6e22e\"\u003enextToken\u003c/span\u003e());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e K \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Integer.\u003cspan style=\"color:#a6e22e\"\u003eparseInt\u003c/span\u003e(st.\u003cspan style=\"color:#a6e22e\"\u003enextToken\u003c/span\u003e());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[][]\u003c/span\u003e g \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eM\u003cspan style=\"color:#f92672\"\u003e][\u003c/span\u003eN\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[][]\u003c/span\u003e visited \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eM\u003cspan style=\"color:#f92672\"\u003e][\u003c/span\u003eN\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e(K\u003cspan style=\"color:#f92672\"\u003e--\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e 0){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                st \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e StringTokenizer(br.\u003cspan style=\"color:#a6e22e\"\u003ereadLine\u003c/span\u003e());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e x \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Integer.\u003cspan style=\"color:#a6e22e\"\u003eparseInt\u003c/span\u003e(st.\u003cspan style=\"color:#a6e22e\"\u003enextToken\u003c/span\u003e());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e y \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Integer.\u003cspan style=\"color:#a6e22e\"\u003eparseInt\u003c/span\u003e(st.\u003cspan style=\"color:#a6e22e\"\u003enextToken\u003c/span\u003e());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                g\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003ex\u003cspan style=\"color:#f92672\"\u003e][\u003c/span\u003ey\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e// Traversal\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e result \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 0;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e dx \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e { 0, 1, 0, \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e1};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e dy \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e { 1, 0, \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e1, 0};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 0; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e M; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e j \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 0; j \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e N; j\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#75715e\"\u003e// 시작 점\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e(g\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003ei\u003cspan style=\"color:#f92672\"\u003e][\u003c/span\u003ej\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e||\u003c/span\u003e visited\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003ei\u003cspan style=\"color:#f92672\"\u003e][\u003c/span\u003ej\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e) \u003cspan style=\"color:#66d9ef\"\u003econtinue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e result\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#75715e\"\u003e// BFS 시작\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    Queue\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[]\u0026gt;\u003c/span\u003e q \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e ArrayDeque\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026gt;\u003c/span\u003e(); \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    q.\u003cspan style=\"color:#a6e22e\"\u003eadd\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e {i, j});\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    visited\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003ei\u003cspan style=\"color:#f92672\"\u003e][\u003c/span\u003ej\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e; \u003cspan style=\"color:#75715e\"\u003e// 시작점 방문\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003eq.\u003cspan style=\"color:#a6e22e\"\u003eisEmpty\u003c/span\u003e()){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e current \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e q.\u003cspan style=\"color:#a6e22e\"\u003epoll\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e dir \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 0; dir \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e 4; dir\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                            \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e currentX \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e current\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003e0\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e dx\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003edir\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                            \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e currentY \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e current\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003e1\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e dy\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003edir\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e(currentX \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e 0 \u003cspan style=\"color:#f92672\"\u003e||\u003c/span\u003e currentY \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e 0 \u003cspan style=\"color:#f92672\"\u003e||\u003c/span\u003e currentX \u003cspan style=\"color:#f92672\"\u003e\u0026gt;=\u003c/span\u003e M \u003cspan style=\"color:#f92672\"\u003e||\u003c/span\u003e currentY \u003cspan style=\"color:#f92672\"\u003e\u0026gt;=\u003c/span\u003e N) \u003cspan style=\"color:#66d9ef\"\u003econtinue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003eg\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003ecurrentX\u003cspan style=\"color:#f92672\"\u003e][\u003c/span\u003ecurrentY\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e||\u003c/span\u003e visited\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003ecurrentX\u003cspan style=\"color:#f92672\"\u003e][\u003c/span\u003ecurrentY\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e) \u003cspan style=\"color:#66d9ef\"\u003econtinue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                            visited\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003ecurrentX\u003cspan style=\"color:#f92672\"\u003e][\u003c/span\u003ecurrentY\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e; \u003cspan style=\"color:#75715e\"\u003e// enque할 때 visited\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                            q.\u003cspan style=\"color:#a6e22e\"\u003eadd\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e {currentX, currentY});\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            System.\u003cspan style=\"color:#a6e22e\"\u003eout\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eprintln\u003c/span\u003e(result);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"배움\"\u003e배움\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e12%에서 메모리 초과가 났었다.\n\u003cul\u003e\n\u003cli\u003e새 좌표에 방문하는 시점 (디큐할 때 (poll)) 에 visited 처리해주고 있었는데 중복 enque가 발생했었다.\u003c/li\u003e\n\u003cli\u003e동일한 좌표가 큐에 여러번 들어가면 최악의 경우 N번 이상 중복 방문하게 된다.\u003c/li\u003e\n\u003cli\u003e이러한 이유로 중복 인큐를 방지하기 위해 큐에서 꺼낸 시점이 아닌, 큐에 넣기 전에 \u003ccode\u003evisited[currentX][currentY] = true\u003c/code\u003e로 수정했다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e👀 다른 사람의 DFS 풀이\n\u003ca href=\"https://chaerim1001.tistory.com/97\"\u003ehttps://chaerim1001.tistory.com/97\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"[PS/BOJ/BFS] 1012. 유기농 배추"},{"content":"문제 Problem Status: Solved Difficulty: Easy Topics: Array\nHint Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.\nThere may be duplicates in the original array.\nNote: An array A rotated by x positions results in an array B of the same length such that B[i] == A[(i+x) % A.length] for every valid index i.\nExample 1:\nInput: nums = [3,4,5,1,2] Output: true Explanation: [1,2,3,4,5] is the original sorted array. You can rotate the array by x = 3 positions to begin on the element of value 3: [3,4,5,1,2].\nExample 2:\nInput: nums = [2,1,3,4] Output: false Explanation: There is no sorted array once rotated that can make nums.\nExample 3:\nInput: nums = [1,2,3] Output: true Explanation: [1,2,3] is the original sorted array. You can rotate the array by x = 0 positions (i.e. no rotation) to make nums.\n제출 Submission add만 있는 간단 singly circular linked list 구현\nclass Node { int data; Node next; Node(int data){ this.data = data; this.next = null; } } class CircularLinkedList { Node head; Node tail; void add(int data){ Node node = new Node(data); if(this.head == null){ this.head = node; this.tail = node; this.tail.next = head; } else { this.tail.next = node; this.tail = node; tail.next = head; } } } class Solution { public boolean check(int[] nums) { int l = nums.length; CircularLinkedList cll1 = new CircularLinkedList(); CircularLinkedList cll2 = new CircularLinkedList(); for (int n : nums) // nums의 값들을 cll1에 넣어주기 cll1.add(n); Arrays.sort(nums); // 정렬 후 정렬된 nums의 값들을 cll2에 넣어주기 for (int n : nums) cll2.add(n); Node startNode = cll1.head; for (int i = 0; i \u0026lt; l; i++) { Node curr1 = startNode; Node curr2 = cll2.head; boolean match = true; do { if (curr1.data != curr2.data) { 첫 노드가 다르면 match되지 않기에 종료. 같으면 계속 비교 match = false; break; } curr1 = curr1.next; curr2 = curr2.next; } while (curr1 != startNode); if (match) return true; // 결과적으로 같으면 startNode = startNode.next; // match되지 않았으면 next 노드로 다시 비교 } return false; } } Editorial n번씩 다 돌려보고 배열 생성하고 비교 -\u0026gt; O(N^2) class Solution {\npublic boolean check(int[] nums) { int n = nums.length; // Construct the rotated array int[] checkSorted = new int[n]; // Iterate through all possible rotation offsets for (int rotationOffset = 0; rotationOffset \u0026lt; n; ++rotationOffset) { int currIndex = 0; for (int index = rotationOffset; index \u0026lt; n; ++index) { checkSorted[currIndex++] = nums[index]; } for (int index = 0; index \u0026lt; rotationOffset; ++index) { checkSorted[currIndex++] = nums[index]; } // Check if the constructed array is sorted boolean isSorted = true; for (int index = 0; index \u0026lt; n - 1; ++index) { if (checkSorted[index] \u0026gt; checkSorted[index + 1]) { isSorted = false; break; } } } } } https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/editorial\nOther Solution 모듈로로 index를 circular하게 활용. 인접한 수끼리 비교해서 왼쪽이 큰 경우가 2번 이상이면 false. (최댓값 다음 최솟값이 인접한 한 번만 허용) -\u0026gt; O(N) class Solution { public boolean check(int[] nums) { int count = 0, n = nums.length;\nfor (int i = 0; i \u0026lt; n; i++) { if (nums[i] \u0026gt; nums[(i + 1) % n]) count++; if (count \u0026gt; 1) return false; return true; } } } https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/solutions/6359740/most-optimal-solution-beats-100-c-java-python-javascript\n","permalink":"http://yeniful.github.io/posts/2025/20250615_leetcode/","summary":"\u003ch2 id=\"문제-problem\"\u003e문제 Problem\u003c/h2\u003e\n\u003cp\u003eStatus: Solved\nDifficulty: Easy\nTopics: Array\u003c/p\u003e\n\u003cp\u003eHint\nGiven an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.\u003c/p\u003e\n\u003cp\u003eThere may be duplicates in the original array.\u003c/p\u003e\n\u003cp\u003eNote: An array A rotated by x positions results in an array B of the same length such that B[i] == A[(i+x) % A.length] for every valid index i.\u003c/p\u003e","title":"[PS/LeetCode/Array] 1752. Check if Array Is Sorted and Rotated"},{"content":"최근 C++과 Java 두 언어를 살펴보면서 자료구조 라이브러리(각각 STL과 컬렉션 프레임워크)에서 느껴지는 차이점이 흥미로웠습니다. 언어별로 용어가 다르거나 인터페이스가 달라 헷갈리는 경우도 있었고, 알게된 것들을 더 잘 기억하기 위해 Java의 컬렉션(Collection) 프레임워크에 대해 간단하게 정리해보겠습니다 :)\nCollection이란? Java에서 컬렉션(Collection) 은 데이터(객체)를 담고 관리하는 그릇, 즉 컨테이너(container) 역할을 하는 패키지입니다. 자바의 컨테이너는 크게 List 계열, Set 계열, Map 계열 3가지로 구분할 수 있어요.\n주의해야할 점은, List 와 Set 은 Collection의 하위 인터페이스지만 Map 은 둘과 구분되는 인터페이스라는 것입니다. Map 은 Collection이 아니지만, Collection과 마찬가지로 데이터를 담는 역할을 하는 친구이기 때문에 함께 정리할게요.\nCollection 프레임워크의 특징 다른 언어들과 비슷하게 자바의 컬렉션 프레임워크는 다음과 같은 특징을 가집니다.\n가변적인 크기: 배열과 달리 크기가 동적으로 변합니다. 표준화된 API: List, Set, Queue, Map 등 인터페이스가 표준화되어 있어 사용법이 일관적입니다. 검증 및 최적화: 이미 구현된 컬렉션 클래스는 검증과 최적화가 되어 있어 직접 자료구조를 구현할 필요가 없습니다. 멀티스레드 환경 지원: ConcurrentHashMap, CopyOnWriteArrayList 등 멀티스레드 환경에서 안전하게 사용할 수 있는 컬렉션 클래스도 제공됩니다. Collection 계열 Collection은 객체 단위로 저장한다는 특징이 있습니다. (Map은 Key-Value 단위 저장) java.util 패키지에서 제공합니다. import java.util.Collection;을 통해 사용할 수 있습니다. 보통은 import java.util.List;나 import java.util.ArrayList;처럼 하위 인터페이스나 구현 클래스를 더 자주 사용합니다. List List의 특징:\n순서 있음 인덱스로 접근이 가능하고 순차적 삽입/삭제에 유리 중복 허용 Iterable 대표 타입\nArrayList: 동적 배열 기반 LinkedList: 이중 연결 리스트 기반 Vector: 동기화 지원, 동적 배열 기반 (레거시) Stack: LIFO 구조, Vector 상속 (레거시) 주요 메서드\nadd(E e): 요소 추가 add(int index, E e): 지정 위치에 요소 추가 get(int index): 인덱스로 요소 조회 set(int index, E e): 지정 위치의 요소 교체 remove(int index): 인덱스로 요소 삭제 remove(Object o): 요소 삭제 contains(Object o): 요소 포함 여부 확인 size(): 요소 개수 반환 indexOf(Object o): 요소의 인덱스 반환 iterator(): 반복자 반환 Set Set의 특징\n순서 보장X 단, LinkedHashSet은 삽입 순서 보장 TreeSet은 자동 정렬 중복 불가 Set의 특징을 이용하여 중복 데이터 제거할 때 유용 Iterable 대표 타입\nHashSet: 해시 테이블 기반, 순서 보장X LinkedHashSet: 삽입 순서 보장 TreeSet: 이진 탐색 트리(레드-블랙 트리) 기반, 오름차순 정렬 보장 주요 메서드\nadd(E e): 요소 추가 (중복 불가) remove(Object o): 요소 삭제 contains(Object o): 요소 포함 여부 확인 size(): 요소 개수 반환 iterator(): 반복자 반환 isEmpty(): 비어있는지 확인 Queue 특징\n일반적으로 FIFO(선입선출) 구조 일부는 우선순위 기반(PriorityQueue) 대표 타입\nLinkedList: Queue 인터페이스 구현 시 FIFO로 동작 PriorityQueue: 우선순위 큐, 힙 기반 주요 메서드\noffer(E e): 요소 추가 poll(): 첫 번째 요소 반환 및 삭제 peek(): 첫 번째 요소 조회 (삭제X) remove(): 첫 번째 요소 반환 및 삭제 (비어있으면 예외 발생) element(): 첫 번째 요소 조회 (비어있으면 예외 발생) size(): 요소 개수 반환 isEmpty(): 비어있는지 확인 Deque 특징\nQueue를 확장한 인터페이스 양쪽에서 삽입/삭제 가능한 큐 대표 타입\nArrayDeque: 배열 기반, 양쪽 입출력 LinkedList: Deque 인터페이스 구현 시 양쪽 입출력 가능 주요 메서드\nofferFirst(E e): 앞쪽에 요소 추가 offerLast(E e): 뒤쪽에 요소 추가 pollFirst(): 앞쪽 요소 반환 및 삭제 pollLast(): 뒤쪽 요소 반환 및 삭제 peekFirst(): 앞쪽 요소 조회 (삭제X) peekLast(): 뒤쪽 요소 조회 (삭제X) removeFirst(): 앞쪽 요소 반환 및 삭제 (비어있으면 예외 발생) removeLast(): 뒤쪽 요소 반환 및 삭제 (비어있으면 예외 발생) size(): 요소 개수 반환 isEmpty(): 비어있는지 확인 Map 계열 Map의 특징\n키를 기준으로 값을 저장하여 Key-Value 쌍을 저장 Key는 중복 불가, Value는 중복 가능 조회 속도 빠름 대표 타입\nHashMap: 해시 테이블 기반, 순서 보장X LinkedHashMap: 삽입 순서 또는 접근 순서 보장 TreeMap: 이진 탐색 트리 기반, 정렬 보장 EnumMap: Enum 타입 키에 특화 WeakHashMap: 약한 참조 기반 IdentityHashMap: 객체 식별 기반 Hashtable: 동기화 지원, (레거시) 주요 메서드:\nput(K key, V value): 키-값 쌍 추가 get(Object key): 키로 값 조회 remove(Object key): 키로 값 삭제 containsKey(Object key): 키 포함 여부 확인 containsValue(Object value): 값 포함 여부 확인 keySet(): 키 집합 반환 values(): 값 집합 반환 entrySet(): 키-값 쌍 집합 반환 size(): 요소 개수 반환 isEmpty(): 비어있는지 확인 궁금했던 내용들 🤔 레거시(Legacy) 컬렉션은 무엇일까? Collection에 대해 조사하다가 레거시 컬렉션이라는 표현을 자주 만날 수 있었는데요. Java의 레거시 컬렉션이란, Java 2(JDK 1.2) 이후 등장한 컬렉션 프레임워크(Collection Framework) 가 도입되기 전에 사용되던 구형 컬렉션 클래스를 의미합니다. 레거시 컬렉션의 예시는 다음과 같아요 :\nVector 동적 배열 기반의 자료구조로, 동기화(Synchronized) 지원 List 인터페이스를 구현한 클래스(요소에 순서가 있고, 중복 허용) 내부적으로 모든 메서드가 동기화되어 있어, 멀티스레드 환경에서 안전하게 사용할 수 있음 하지만 오늘날에는 ArrayList와 Collections.synchronizedList() 조합을 더 많이 사용 [예시] Vector\nVector\u0026lt;String\u0026gt; vector = new Vector\u0026lt;\u0026gt;(); vector.add(\u0026#34;apple\u0026#34;); vector.add(\u0026#34;banana\u0026#34;); System.out.println(vector); // [apple, banana] Stack LIFO(Last In First Out, 후입선출) 구조의 자료구조 Vector 클래스를 상속받아 구현됨 push(), pop(), peek() 등 스택 연산 지원 현재는 Deque 인터페이스(예: ArrayDeque)를 사용하는 것을 권장 [예시] Stack\nStack\u0026lt;String\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(\u0026#34;apple\u0026#34;); stack.push(\u0026#34;banana\u0026#34;); System.out.println(stack.pop()); // banana Hashtable Key-Value 쌍을 저장하는 해시 기반의 자료구조 동기화(Synchronized) 지원 Map 인터페이스를 구현한 클래스(키는 중복 불가, 값은 중복 가능) 현재는 HashMap과 ConcurrentHashMap이 더 많이 사용 [예시] Hashtable\nHashtable\u0026lt;String, Integer\u0026gt; table = new Hashtable\u0026lt;\u0026gt;(); table.put(\u0026#34;apple\u0026#34;, 1); table.put(\u0026#34;banana\u0026#34;, 2); System.out.println(table.get(\u0026#34;apple\u0026#34;)); // 1 레거시 컬렉션의 문제점 성능 저하: 내부적으로 모든 메서드가 동기화되어 있어, 단일 스레드 환경에서는 불필요한 성능 저하가 발생할 수 있음 기능 제한: 컬렉션 프레임워크의 다양한 인터페이스와 기능을 지원하지 않음 유지보수 어려움: 레거시 코드는 최신 코드와 호환성이 떨어질 수 있음 레거시 컬렉션 대안 ArrayList (Vector 대안) 동기화가 필요하다면 Collections.synchronizedList(new ArrayList\u0026lt;\u0026gt;()) 사용 ArrayDeque (Stack 대안) ArrayDeque는 스택과 큐 모두로 활용 가능 HashMap (Hashtable 대안) 동기화가 필요하다면 ConcurrentHashMap 사용 ✅ 정리 컬렉션 프레임워크의 ArrayList, ArrayDeque, HashMap, ConcurrentHashMap 사용을 권장합니다.\n🤔 Collection과 Collections의 차이는 무엇일까? Collections는 데이터를 담는 컨테이너가 아니라 컨테이너(List, Set, Map 등)를 조작하거나 생성하는 유틸 메서드 묶음 (쉽게 표현하자면 도구 상자)입니다. import java.util.Collections;를 통해 사용할 수 있습니다.\n[예시] Collections를 import해서 sort 메서드 사용\nimport java.util.Collections; List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;C\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;); Collections.sort(list); ✅ 정리 Collection은 컨테이너 모음, Collections는 컨테이너를 다루기 위한 도구 모음 패키지\n🤔 Map은 Iterable할까? 자바에서 Map 인터페이스는 Iterable을 직접 구현하지 않습니다.\n즉, Map 객체 자체로는 iterator() 메서드를 직접 호출할 수 없습니다.\nMap은 Collection 계층이 아닌 별도의 인터페이스이자 key-value 쌍을 저장하는 구조이기 때문입니다.\n하지만 Map의 key, value, 또는 entry(키-값 쌍)를 Set이나 Collection 형태로 얻어온 후에는 Iterable을 사용할 수 있습니다.\n예를 들어,\nmap.keySet(): 키들의 집합(Set) 반환 → Iterable map.values(): 값들의 집합(Collection) 반환 → Iterable map.entrySet(): 키-값 쌍의 집합(Set) 반환 → Iterable 이렇게 얻은 Set이나 Collection 객체는 Iterable을 구현하므로, for-each문이나 Iterator를 사용해 순회할 수 있습니다.\n[예시] Map으로부터 Iterable한 entrySet을 만든 경우\nimport java.util.Map; import java.util.HashMap; import java.util.Iterator; import java.util.Set; import java.util.Map.Entry; public class MapIterationExample { public static void main(String[] args) { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;apple\u0026#34;, 1); map.put(\u0026#34;banana\u0026#34;, 2); map.put(\u0026#34;orange\u0026#34;, 3); // 1. for-each 루프로 entrySet 순회 for (Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { System.out.println(\u0026#34;Key: \u0026#34; + entry.getKey() + \u0026#34;, Value: \u0026#34; + entry.getValue()); } // 2. Iterator로 entrySet 순회 Set\u0026lt;Entry\u0026lt;String, Integer\u0026gt;\u0026gt; entrySet = map.entrySet(); Iterator\u0026lt;Entry\u0026lt;String, Integer\u0026gt;\u0026gt; entryIterator = entrySet.iterator(); while (entryIterator.hasNext()) { Entry\u0026lt;String, Integer\u0026gt; entry = entryIterator.next(); System.out.println(\u0026#34;Key: \u0026#34; + entry.getKey() + \u0026#34;, Value: \u0026#34; + entry.getValue()); } } } ✅ 정리 Map 자체는 Iterable이 아니지만, entrySet() 등으로 얻은 Set 객체는 Iterable합니다.\ncf) C++의 std::map은 직접적으로 \u0026ldquo;Iterable\u0026quot;이라는 인터페이스를 구현하는 것은 아니지만, STL 컨테이너들은 모두 반복자(iterator)를 제공하여 순회가 가능합니다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; int main() { std::map\u0026lt;std::string, int\u0026gt; myMap; myMap[\u0026#34;apple\u0026#34;] = 1; myMap[\u0026#34;banana\u0026#34;] = 2; myMap[\u0026#34;orange\u0026#34;] = 3; // 범위 기반 for문 (C++11 이상) for (const auto\u0026amp; pair : myMap) { std::cout \u0026lt;\u0026lt; \u0026#34;Key: \u0026#34; \u0026lt;\u0026lt; pair.first \u0026lt;\u0026lt; \u0026#34;, Value: \u0026#34; \u0026lt;\u0026lt; pair.second \u0026lt;\u0026lt; std::endl; } // 반복자를 이용한 순회 for (auto iter = myMap.begin(); iter != myMap.end(); ++iter) { std::cout \u0026lt;\u0026lt; \u0026#34;Key: \u0026#34; \u0026lt;\u0026lt; iter-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, Value: \u0026#34; \u0026lt;\u0026lt; iter-\u0026gt;second \u0026lt;\u0026lt; std::endl; } } 즉, Java의 Map과 다르게 별도의 변환이 없어도 C++의 map은 iterator나 범위 기반 for문을 통해 직접 순회가 가능하기 때문에 실질적으로 iterable하다고 할 수 있습니다.\n글을 마치며 각 컬렉션 및 타입들의 주요 특징을 이해하면, 상황에 맞는 효율적인 코드를 쉽고 빠르게 작성할 수 있습니다. 공부한 내용을 정리하다 보니 글에 부족한 부분이나 잘못된 내용이 있을 수 있습니다. 잘못된 내용이나 보완하면 좋을 내용, 또는 궁금한 점이 있다면 언제든 댓글로 남겨주세요!\n👀 Reference C++과 Java를 비교하면서 설명하는 좋은 블로그를 발견해서 링크를 함께 남깁니다 :)\nOrientation: https://justkode.kr/java/cpp-to-java-0/ Collections: https://justkode.kr/java/cpp-to-java-8/ ","permalink":"http://yeniful.github.io/posts/2025/20250614_java/","summary":"\u003cp\u003e최근 C++과 Java 두 언어를 살펴보면서 자료구조 라이브러리(각각 STL과 컬렉션 프레임워크)에서 느껴지는 차이점이 흥미로웠습니다.\n언어별로 용어가 다르거나 인터페이스가 달라 헷갈리는 경우도 있었고, 알게된 것들을 더 잘 기억하기 위해 Java의 컬렉션(Collection) 프레임워크에 대해 간단하게 정리해보겠습니다 :)\u003c/p\u003e\n\u003ch2 id=\"collection이란\"\u003eCollection이란?\u003c/h2\u003e\n\u003cp\u003eJava에서 \u003cstrong\u003e컬렉션(Collection)\u003c/strong\u003e 은 데이터(객체)를 담고 관리하는 그릇, 즉 컨테이너(container) 역할을 하는 패키지입니다.\n자바의 컨테이너는 크게 \u003ccode\u003eList\u003c/code\u003e 계열, \u003ccode\u003eSet\u003c/code\u003e 계열, \u003ccode\u003eMap\u003c/code\u003e 계열 3가지로 구분할 수 있어요.\u003c/p\u003e\n\u003cp\u003e주의해야할 점은, \u003ccode\u003eList\u003c/code\u003e 와 \u003ccode\u003eSet\u003c/code\u003e 은 Collection의 하위 인터페이스지만 \u003ccode\u003eMap\u003c/code\u003e 은 둘과 구분되는 인터페이스라는 것입니다.\n\u003ccode\u003eMap\u003c/code\u003e 은 Collection이 아니지만, Collection과 마찬가지로 데이터를 담는 역할을 하는 친구이기 때문에 함께 정리할게요.\u003c/p\u003e","title":"[Java] Java의 Collection Framework (컬렉션 프레임워크)를 알아보자!"},{"content":"42862 체육복 🔗 문제 링크\n내 풀이 배열의 크기를 n + 2로 만들어줘서 1번 째 학생과 n번 째 학생이 앞뒤 학생에게 체육복을 빌릴 수 있는지를 판별할 때 out of range를 방지할 수 있다.\nclass Solution { public int solution(int n, int[] lost, int[] reserve) { int answer = 0; int[] states = new int[n + 2]; states[0] = -1; states[n + 1] = -1; for(int i = 1 ; i \u0026lt;= n ; i++) states[i] = 1; for(int num : lost) states[num] -= 1; for(int num : reserve) states[num] += 1; int i = 1; do { if (states[i - 1] == 2 \u0026amp;\u0026amp; states[i] == 0){ states[i] += 1; states[i - 1] -= 1; } else if (states[i + 1] == 2 \u0026amp;\u0026amp; states[i] == 0) { states[i] += 1; states[i + 1] -= 1; } i++; } while (i \u0026lt;= n); for (int state : states) if (state \u0026gt;= 1) answer++; return answer; } } 다른 사람 풀이 조건문 안에서 ++, -- 연산을 해도 총 인원에 영향을 주지 않기 때문에 answer를 미리 n으로 설정하고, 못빌리는 것이 확정일 때 n-- 해주는 접근이 좋았다. 시간 복잡도가 상수배 이라서 큰 영향은 없을 수 있지만, states 전체를 순회하면서 카운팅하는 부분을 제외하면 루프 한 번을 덜 돌아도 됐었다. 그리고 배열의 크기를 n + 2로 지정해줬기 때문에 굳이 do-while을 쓰지 않아도 됐었다.\nclass Solution { public int solution(int n, int[] lost, int[] reserve) { int[] people = new int[n]; int answer = n; for (int l : lost) people[l-1]--; for (int r : reserve) people[r-1]++; for (int i = 0; i \u0026lt; people.length; i++) { if(people[i] == -1) { if(i-1\u0026gt;=0 \u0026amp;\u0026amp; people[i-1] == 1) { people[i]++; people[i-1]--; }else if(i+1\u0026lt; people.length \u0026amp;\u0026amp; people[i+1] == 1) { people[i]++; people[i+1]--; }else answer--; } } return answer; } } 💡 노트 배열을 선언할 때 기본타입(Primitive type)의 배열인 경우 원소들은 초기 값을 가지고 있는 반면에(int = 0) 참조타입(Reference type)의 배열을 선언했을 경우 배열 원소의 초기값이 null임을 주의해야 한다.\nint[] arr = new int[3]; // 3의 크기를 가지고 초기값 0으로 채워진 배열 생성 // arr[0] \u0026gt;\u0026gt; null // arr[1] \u0026gt;\u0026gt; null // arr[2] \u0026gt;\u0026gt; null // Class 타입(참조 타입)의 인스턴스를 원소로 가지는 배열을 생성했을 때. Student[] students = new Student[5]; //Student Class의 인스턴스 최대 5개 할당할 수 있는 배열 // students[0] \u0026gt;\u0026gt; null // students[1] \u0026gt;\u0026gt; null // students[2] \u0026gt;\u0026gt; null // students[3] \u0026gt;\u0026gt; null // students[4] \u0026gt;\u0026gt; null 👀 참고 링크\n42862 체육복 🔗 문제 링크\n","permalink":"http://yeniful.github.io/posts/2025/20250601_programmers/","summary":"\u003ch2 id=\"42862-체육복\"\u003e42862 체육복\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42862\"\u003e🔗 문제 링크\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"내-풀이\"\u003e내 풀이\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e배열의 크기를 \u003ccode\u003en + 2\u003c/code\u003e로 만들어줘서 1번 째 학생과 n번 째 학생이 앞뒤 학생에게 체육복을 빌릴 수 있는지를 판별할 때 out of range를 방지할 수 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eclass Solution {\n    public int solution(int n, int[] lost, int[] reserve) {\n        int answer = 0;\n        int[] states = new int[n + 2];\n        states[0] = -1;\n        states[n + 1] = -1;\n        for(int i = 1 ; i \u0026lt;= n ; i++) states[i] = 1;\n        for(int num : lost) states[num] -= 1;\n        for(int num : reserve) states[num] += 1;\n        \n        int i = 1;\n        do {\n            if (states[i - 1] == 2 \u0026amp;\u0026amp; states[i] == 0){\n                states[i] += 1;\n                states[i - 1] -= 1;\n            } else if (states[i + 1] == 2 \u0026amp;\u0026amp; states[i] == 0) {\n                states[i] += 1;\n                states[i + 1] -= 1;\n            }\n            i++;\n        } while (i \u0026lt;= n);\n        \n        for (int state : states) if (state \u0026gt;= 1) answer++;\n            \n        return answer;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"다른-사람-풀이\"\u003e다른 사람 풀이\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e조건문 안에서 \u003ccode\u003e++\u003c/code\u003e, \u003ccode\u003e--\u003c/code\u003e 연산을 해도 총 인원에 영향을 주지 않기 때문에 \u003ccode\u003eanswer\u003c/code\u003e를 미리 \u003ccode\u003en\u003c/code\u003e으로 설정하고, 못빌리는 것이 확정일 때 \u003ccode\u003en--\u003c/code\u003e 해주는 접근이 좋았다. 시간 복잡도가 상수배 이라서 큰 영향은 없을 수 있지만, states 전체를 순회하면서 카운팅하는 부분을 제외하면 루프 한 번을 덜 돌아도 됐었다.\n그리고 배열의 크기를 n + 2로 지정해줬기 때문에 굳이 do-while을 쓰지 않아도 됐었다.\u003c/p\u003e","title":"프로그래머스 Greedy 유형"},{"content":"\n다시 돌아온 깃허브 블로그 반가워요 👋 안녕하세요, 예니입니다-! 👻 (주섬주섬 이사떡을 꺼낸다)\n작년부터 Medium에서 글쓰기를 다시 시작하기도 했고, 기록에 대한 중요성을 느껴서 기술 블로그를 다시 운영해보려고 합니다. 오래 전부터 깃허브 블로그 운영을 여러 차례 시도했지만, 매번 손을 놓아버리게 되었어요. 초기 세팅만 열심히\u0026hellip;🎨 하다가 글쓰기 복잡도가 증가하면 글을 잘 올리지 않게 되었는데, 예쁜 디자인 다 필요 없고 일단 기본 테마로 꾸준히 써보라는 개발자 M님의 조언을 다시 한 번 되새겨봅니다.\n티스토리부터 시작해서 Velog, DevTO, Hashnode, Substack 등 여러 해외 개발자 블로그 플랫폼들도 경험해봤습니다. WordPress나 Wix같이 유료 서비스 빼고 거의 다 써봤는데 정착하고 싶은 곳이 정말정말 없더라구요. 🥲 무엇보다도 많은 서비스들이 빠르게 생기고, 빠르게 사라지기에 플랫폼 의존이 덜 한 도구를 선택하고 싶었어요.\nHugo 기존에 사용했던 정적 페이지 생성기 Jekyll을 사용하려고 했으나, 루비 세팅이 번거롭고 (Rosetta 이슈가 아직도\u0026hellip;) Jekyll 말고 여러 도구들이 생긴 만큼 다른 도구도 사용해보고싶은 마음에 이번에는 Hugo를 선택하게 되었어요.\nHugo는 \u0026ldquo;세상에서 제일 빠른 웹 사이트 생성 프레임워크\u0026quot;라는 캐치프라이즈로 서비스를 소개하고 있는데요, 이름에서 슬쩍 눈치챌 수 있듯이 언어 \u0026lsquo;Go\u0026rsquo; (고랭)으로 만들어졌다고 해요. 이름 정말 잘 지었죠? 테마도 다양하고, 최근까지 업데이트가 계속된 테마들이 많아서 놀랐어요. Hugo Theme 그리고 quick start 튜토리얼을 따라 차근차근 해보니 세팅이 까다롭지 않았어요. (Theme은 아주 심플하게 튜토리얼에서 사용하고 있는 ananke를 선택했답니다. 기능 추가에 어려움이 있어서 PaperMod로 변경 - 2025.6.11)\nHugo를 사용하면서 공유할만한 내용이 생기면 글로 다뤄볼게요. 지속가능한 테크 블로깅을 꿈꾸며, 오늘의 글은 짧게 마무리 해보겠습니다 : ) 자주 만나요~ 제발~\n","permalink":"http://yeniful.github.io/posts/2025/20250425_%EC%9D%B4%EC%82%AC/","summary":"\u003cp\u003e\u003cimg alt=\"이사떡\" loading=\"lazy\" src=\"/images/Sirutteok.jpg\"\u003e\u003c/p\u003e\n\u003ch3 id=\"다시-돌아온-깃허브-블로그-반가워요-\"\u003e다시 돌아온 깃허브 블로그 반가워요 👋\u003c/h3\u003e\n\u003cp\u003e안녕하세요, 예니입니다-! 👻 (주섬주섬 이사떡을 꺼낸다)\u003c/p\u003e\n\u003cp\u003e작년부터 Medium에서 글쓰기를 다시 시작하기도 했고, 기록에 대한 중요성을 느껴서 기술 블로그를 다시 운영해보려고 합니다.\n오래 전부터 깃허브 블로그 운영을 여러 차례 시도했지만, 매번 손을 놓아버리게 되었어요.\n초기 세팅만 열심히\u0026hellip;🎨 하다가 글쓰기 복잡도가 증가하면 글을 잘 올리지 않게 되었는데, 예쁜 디자인 다 필요 없고 일단 기본 테마로 꾸준히 써보라는 개발자 M님의 조언을 다시 한 번 되새겨봅니다.\u003c/p\u003e\n\u003cp\u003e티스토리부터 시작해서 Velog,  DevTO, Hashnode, Substack 등 여러 해외 개발자 블로그 플랫폼들도 경험해봤습니다. WordPress나 Wix같이 유료 서비스 빼고 거의 다 써봤는데 정착하고 싶은 곳이 정말정말 없더라구요. 🥲 무엇보다도 많은 서비스들이 빠르게 생기고, 빠르게 사라지기에 플랫폼 의존이 덜 한 도구를 선택하고 싶었어요.\u003c/p\u003e","title":"똑똑똑, 이사왔어요~ 🛻💨"},{"content":"모티베이션 \u0026ldquo;재사용되는 View를 구조체로 빼야 하나, 아니면 그냥 함수로 만들어도 될까?\u0026rdquo;\nView를 만들 때 특별한 기준 없이 View를 만들 때 습관적으로 구조체를 만들거나, 간단한 건 함수로 처리하곤 했는데요. 앱의 구조와 성능, 유지보수 방식에 꽤 중요한 영향을 준다는 것을 알게 되었고, 간단한 내용이지만 한 번 정리해보고 싶었습니다.\n그래서 이번 글에서는 Apple 공식 문서와 WWDC 세션에서 강조한 원리를 바탕으로 struct View vs. @ViewBuilder 함수의 차이를 정리해보려고 합니다.\n두 가지 방식 살펴보기 먼저 동일한 UI를 두 가지 방식으로 만들어봤습니다.\n구조체 View로 분리\nstruct ProfileCard: View { let name: String let role: String var body: some View { VStack(alignment: .leading, spacing: 8) { Text(name) .font(.headline) Text(role) .font(.subheadline) .foregroundColor(.secondary) } .padding() .background(Color(.systemBackground)) .cornerRadius(12) } } // 사용 ProfileCard(name: \u0026#34;예니\u0026#34;, role: \u0026#34;iOS Developer\u0026#34;) 함수로 분리\n@ViewBuilder func profileCard(name: String, role: String) -\u0026gt; some View { VStack(alignment: .leading, spacing: 8) { Text(name) .font(.headline) Text(role) .font(.subheadline) .foregroundColor(.secondary) } .padding() .background(Color(.systemBackground)) .cornerRadius(12) } // 사용 profileCard(name: \u0026#34;예니\u0026#34;, role: \u0026#34;iOS Developer\u0026#34;) 겉보기에 유사해 보이지만, SwiftUI 내부에서는 이 둘을 다르게 처리합니다.\n6가지 차이 1. 상태(State)를 가질 수 있는가 SwiftUI에서 상태(@State, @Binding, @StateObject)는 View의 identity와 lifetime에 연결되는 값입니다.\n그리고 SwiftUI는 구조체로 만든 View에만 이러한 상태 저장소를 생성합니다. 즉, 상태는 View 구조체 내부에서만 선언할 수 있습니다.\nstruct ExpandableCard: View { let title: String @State private var isExpanded = false // ✅ 자체 상태 보유 var body: some View { VStack { Button(title) { isExpanded.toggle() } if isExpanded { Text(\u0026#34;상세 내용입니다\u0026#34;) } } } } 반면 함수는 identity가 없으므로 자체 상태 저장소를 가질 수 없습니다. 상태가 필요하다면 부모 View에서 관리하고 Binding으로 넘겨받아야 합니다. (identity에 대해서는 다음 항목에서 설명하겠습니다.)\n// 함수는 자체 @State를 가질 수 없음 @ViewBuilder func expandableCard(title: String, isExpanded: Binding\u0026lt;Bool\u0026gt;) -\u0026gt; some View { VStack { Button(title) { isExpanded.wrappedValue.toggle() } if isExpanded.wrappedValue { Text(\u0026#34;상세 내용입니다\u0026#34;) } } } 즉, struct View는 SwiftUI가 관리하는 state storage를 갖고 있지만, 함수 기반 View는 갖고 있지 않아서 state를 가질 수 없습니다.\n2. View Identity WWDC21의 Demystify SwiftUI 에서 SwiftUI의 핵심 원리로 세 가지를 소개합니다\nIdentity Lifetime Dependencies 여기서 Identity는 다음을 의미합니다:\n\u0026ldquo;Identity is how SwiftUI recognizes elements as the same or distinct across multiple updates of your app.\u0026rdquo;\n즉, Identity란 SwiftUI가 앱의 여러 업데이트에서 요소를 같은 것 또는 다른 것으로 인식하는 방식입니다.\nSwiftUI는 두 가지 방식으로 View를 식별합니다.\nExplicit Identity : 개발자가 직접 제공하는 식별자 (예: ForEach의 id, .id() modifier) Structural Identity : View의 타입과 계층 구조 내 위치로 암묵적으로 부여되는 식별자 구조체로 만든 View는 고유한 타입이 있기 때문에 identity가 있습니다. 즉, SwiftUI는 구조체로 만든 View에 명확한 structural identity를 부여합니다.\n따라서 SwiftUI는 \u0026ldquo;이 ProfileCard는 이전에 있던 같은 ProfileCard다.\u0026ldquo;를 인식합니다.\nstruct ParentView: View { @State private var count = 0 var body: some View { VStack { Text(\u0026#34;Count: \\(count)\u0026#34;) Button(\u0026#34;증가\u0026#34;) { count += 1 } // 고유 identity를 가지는 ProfileCard ProfileCard(name: \u0026#34;김개발\u0026#34;, role: \u0026#34;iOS\u0026#34;) } } } 하지만 함수로 만든 View는 매 렌더링마다 \u0026ldquo;새로 구성된 View\u0026quot;로 취급됩니다.\nIdentity는 직전에 설명드린 State와도 관련이 있습니다. WWDC21 세션에서는 State와 Identity의 관계를 명확히 설명합니다:\nSwiftUI가 View를 보고 State나 StateObject를 발견하면, 해당 데이터를 View의 lifetime 동안 유지해야 한다는 것을 인지합니다.\n\u0026ldquo;When SwiftUI is looking at your view and sees a State or a StateObject, it knows that it needs to persist that piece of data throughout the view\u0026rsquo;s lifetime.\u0026rdquo;\nState의 지속성(Persistence)은 View의 lifetime에 연결되어 있습니다.\n\u0026ldquo;The persistence of your state is tied to the lifetime of your views.\u0026rdquo;\n구조체로 만든 View와 달리 함수로 만든 View는 단순히 View를 반환하는 코드일 뿐, 별도의 identity를 형성하지 않습니다. 함수를 호출하는 부모 View가 다시 그려질 때마다 함수도 재호출됩니다.\n3. @ViewBuilder의 역할 ViewBuilder 문서에 따르면, ViewBuilder는 \u0026ldquo;클로저로부터 View를 구성하는 커스텀 파라미터 속성\u0026quot;입니다. WWDC 세션에서는 함수에 @ViewBuilder를 적용하는 방법도 소개합니다:\n\u0026ldquo;Swift does not infer helper functions to be view builders by default, but we can opt into that by manually applying the ViewBuilder attribute ourselves.\u0026rdquo;\n하지만 @ViewBuilder를 함수에 적용해도 해당 함수가 구조체 View와 동일한 identity를 갖게 되는 것은 아닙니다. ViewBuilder는 단지 여러 View를 조합할 수 있게 해주는 문법적 편의 기능일 뿐입니다.\n4. AnyView 회피와 성능 WWDC21 세션에서는 AnyView의 과도한 사용을 피하라고 권고합니다\n\u0026ldquo;In general, we recommend avoiding AnyViews whenever possible. Having too many AnyViews will often make code harder to read and understand\u0026hellip; And because AnyView hides static type information from the compiler, it can sometimes prevent helpful diagnostic errors and warnings from being surfaced in your code. Finally, keep in mind that using AnyView when you don\u0026rsquo;t need to can result in worse performance.\u0026rdquo;\n함수에서 여러 타입의 View를 반환하려면 AnyView로 감싸거나 @ViewBuilder를 사용해야 합니다. 구조체를 사용하면 각 View가 명확한 타입을 가지므로 이러한 문제를 피할 수 있습니다.\n5. View Life Cycle 함수로 반환한 View에도 onAppear, onDisappear, task 같은 생명주기 modifier를 붙일 수는 있습니다. 하지만 함수는 독립적인 identity가 없으므로, 해당 modifier는 부모 View의 생명주기를 따르게 됩니다.\n반면 구조체는 자체적인 identity와 lifetime을 가지므로, 생명주기 modifier가 해당 View의 등장/퇴장 시점에 정확히 동작합니다.\nstruct DataFetchingView: View { @State private var data: [Item] = [] var body: some View { List(data) { item in Text(item.name) } .onAppear { // View가 나타날 때 데이터 로드 } .task { // 비동기 작업 수행 } } } 정리: 언제 무엇을 선택할까 상황 선택 근거 자체 상태(@State 등)가 필요할 때 구조체 함수는 상태를 가질 수 없음 여러 화면에서 재사용할 컴포넌트 구조체 독립적인 identity와 타입으로 관리 가능 onAppear, task 등 생명주기 활용 구조체 의미 있는 lifetime 보장 복잡한 로직이 포함된 View 구조체 명확한 identity로 성능 최적화 같은 View 내에서 단순 중복 제거 함수 빠르고 간편함 상태 없는 아주 작은 UI 조각 함수 오버헤드 없이 간단히 처리 결론 기본적으로 구조체 친화적인 SwiftUI는 View를 만들 때 구조체 사용을 권장합니다. 그리고 상황적으로 유연하게 함수로 View를 그리는 것이 가능합니다.\n재사용·확장성·상태·생명주기가 필요하다 → struct 한 화면 안에서의 작은 UI 조각 → 함수 SwiftUI는 Identity, Lifetime, Dependencies라는 원리를 기반으로 작동하는데요, 이 관점에서 보면 struct View는 SwiftUI가 기대하는 방식에 자연스럽게 맞춰져 있고, 함수 기반 View는 역할이 제한적입니다.\n함수는 \u0026ldquo;같은 View 안에서 반복되는 작은 UI 조각을 빠르게 추출\u0026quot;하는 용도로 제한적으로 사용하면 좋습니다. 만약 함수가 점점 복잡해지거나, 상태가 필요해지거나, 다른 곳에서도 쓰이게 된다면 그때 구조체로 승격시키면 됩니다.\n참고 자료 WWDC21: Demystify SwiftUI Apple Developer Documentation: View Apple Developer Documentation: State Apple Developer Documentation: ViewBuilder WWDC24: SwiftUI essentials ","permalink":"http://yeniful.github.io/posts/2025/20250301_swiftuiview/","summary":"\u003ch2 id=\"모티베이션\"\u003e모티베이션\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u0026ldquo;재사용되는 View를 구조체로 빼야 하나, 아니면 그냥 함수로 만들어도 될까?\u0026rdquo;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eView를 만들 때 특별한 기준 없이 View를 만들 때 습관적으로 구조체를 만들거나, 간단한 건 함수로 처리하곤 했는데요. 앱의 구조와 성능, 유지보수 방식에 꽤 중요한 영향을 준다는 것을 알게 되었고, 간단한 내용이지만 한 번 정리해보고 싶었습니다.\u003c/p\u003e\n\u003cp\u003e그래서 이번 글에서는 Apple 공식 문서와 WWDC 세션에서 강조한 원리를 바탕으로 \u003cstrong\u003estruct View vs. @ViewBuilder 함수\u003c/strong\u003e의 차이를 정리해보려고 합니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"두-가지-방식-살펴보기\"\u003e두 가지 방식 살펴보기\u003c/h2\u003e\n\u003cp\u003e먼저 동일한 UI를 두 가지 방식으로 만들어봤습니다.\u003c/p\u003e","title":"[SwiftUI] struct View vs @ViewBuilder 함수, 뭐가 다를까?"}]