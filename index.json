[{"content":"최근 C++과 Java 두 언어를 살펴보면서 자료구조 라이브러리(각각 STL과 컬렉션 프레임워크)에서 느껴지는 차이점이 흥미로웠습니다. 🤩 언어별로 용어가 다르거나 인터페이스가 달라 헷갈리는 경우도 있었고, 알게된 것들을 더 잘 기억하기 위해 Java의 컬렉션(Collection) 프레임워크에 대해 간단하게 정리해보겠습니다 :)\nCollection이란? Java에서 컬렉션(Collection) 은 데이터(객체)를 담고 관리하는 그릇, 즉 컨테이너(container) 역할을 하는 패키지입니다. 자바의 컨테이너는 크게 List 계열, Set 계열, Map 계열 3가지로 구분할 수 있어요.\n주의해야할 점은, List 와 Set 은 Collection의 하위 인터페이스지만 Map 은 둘과 구분되는 인터페이스라는 것입니다. Map 은 Collection이 아니지만, Collection과 마찬가지로 데이터를 담는 역할을 하는 친구이기 때문에 함께 정리할게요.\nCollection 프레임워크의 특징 다른 언어들과 비슷하게 자바의 컬렉션 프레임워크는 다음과 같은 특징을 가집니다\n가변적인 크기: 배열과 달리 크기가 동적으로 변합니다. 표준화된 API: List, Set, Queue, Map 등 인터페이스가 표준화되어 있어 사용법이 일관적입니다. 검증 및 최적화: 이미 구현된 컬렉션 클래스는 검증과 최적화가 되어 있어 직접 자료구조를 구현할 필요가 없습니다. 멀티스레드 환경 지원: ConcurrentHashMap, CopyOnWriteArrayList 등 멀티스레드 환경에서 안전하게 사용할 수 있는 컬렉션 클래스도 제공됩니다. Collection 계열 Collection은 객체 단위로 저장한다는 특징이 있습니다. (Map은 Key-Value 단위 저장) java.util 패키지에서 제공합니다. import java.util.Collection;을 통해 사용할 수 있습니다. 보통은 import java.util.List;나 import java.util.ArrayList;처럼 하위 인터페이스나 구현 클래스를 더 자주 사용합니다. List List의 특징:\n순서 있음 인덱스로 접근이 가능하고 순차적 삽입/삭제에 유리 중복 허용 Iterable 대표 타입\nArrayList: 동적 배열 기반 LinkedList: 이중 연결 리스트 기반 Vector: 동기화 지원, 동적 배열 기반 (레거시) Stack: LIFO 구조, Vector 상속 (레거시) 주요 메서드\nadd(E e): 요소 추가 add(int index, E e): 지정 위치에 요소 추가 get(int index): 인덱스로 요소 조회 set(int index, E e): 지정 위치의 요소 교체 remove(int index): 인덱스로 요소 삭제 remove(Object o): 요소 삭제 contains(Object o): 요소 포함 여부 확인 size(): 요소 개수 반환 indexOf(Object o): 요소의 인덱스 반환 iterator(): 반복자 반환 Set Set의 특징\n순서 보장X 단, LinkedHashSet은 삽입 순서 보장 TreeSet은 자동 정렬 중복 불가 Set의 특징을 이용하여 중복 데이터 제거할 때 유용 Iterable 대표 타입\nHashSet: 해시 테이블 기반, 순서 보장X LinkedHashSet: 삽입 순서 보장 TreeSet: 이진 탐색 트리(레드-블랙 트리) 기반, 오름차순 정렬 보장 주요 메서드\nadd(E e): 요소 추가 (중복 불가) remove(Object o): 요소 삭제 contains(Object o): 요소 포함 여부 확인 size(): 요소 개수 반환 iterator(): 반복자 반환 isEmpty(): 비어있는지 확인 Queue 특징\n일반적으로 FIFO(선입선출) 구조 (혹은 후입선출(LIFO)) 일부는 우선순위 기반(PriorityQueue) 대표 타입\nLinkedList: Queue 인터페이스 구현 시 FIFO로 동작 PriorityQueue: 우선순위 큐, 힙 기반 주요 메서드\noffer(E e): 요소 추가 poll(): 첫 번째 요소 반환 및 삭제 peek(): 첫 번째 요소 조회 (삭제X) remove(): 첫 번째 요소 반환 및 삭제 (비어있으면 예외 발생) element(): 첫 번째 요소 조회 (비어있으면 예외 발생) size(): 요소 개수 반환 isEmpty(): 비어있는지 확인 Deque 특징\n양쪽에서 삽입/삭제 가능한 큐 대표 타입\nArrayDeque: 배열 기반, 양쪽 입출력 LinkedList: Deque 인터페이스 구현 시 양쪽 입출력 가능 주요 메서드\nofferFirst(E e): 앞쪽에 요소 추가 offerLast(E e): 뒤쪽에 요소 추가 pollFirst(): 앞쪽 요소 반환 및 삭제 pollLast(): 뒤쪽 요소 반환 및 삭제 peekFirst(): 앞쪽 요소 조회 (삭제X) peekLast(): 뒤쪽 요소 조회 (삭제X) removeFirst(): 앞쪽 요소 반환 및 삭제 (비어있으면 예외 발생) removeLast(): 뒤쪽 요소 반환 및 삭제 (비어있으면 예외 발생) size(): 요소 개수 반환 isEmpty(): 비어있는지 확인 Map 계열 Map의 특징\n키를 기준으로 값을 저장하여 Key-Value 쌍을 저장 Key는 중복 불가, Value는 중복 가능 조회 속도 빠름 대표 타입\nHashMap: 해시 테이블 기반, 순서 보장X LinkedHashMap: 삽입 순서 또는 접근 순서 보장 TreeMap: 이진 탐색 트리 기반, 정렬 보장 EnumMap: Enum 타입 키에 특화 WeakHashMap: 약한 참조 기반 IdentityHashMap: 객체 식별 기반 Hashtable: 동기화 지원, (레거시) 주요 메서드:\nput(K key, V value): 키-값 쌍 추가 get(Object key): 키로 값 조회 remove(Object key): 키로 값 삭제 containsKey(Object key): 키 포함 여부 확인 containsValue(Object value): 값 포함 여부 확인 keySet(): 키 집합 반환 values(): 값 집합 반환 entrySet(): 키-값 쌍 집합 반환 size(): 요소 개수 반환 isEmpty(): 비어있는지 확인 🤔 레거시(Legacy) 컬렉션은 무엇일까? Java의 레거시 컬렉션이란, Java 2(JDK 1.2) 이후 등장한 **컬렉션 프레임워크(Collection Framework)**가 도입되기 전에 사용되던 구형 컬렉션 클래스를 의미합니다.\nVector 동적 배열 기반의 자료구조로, 동기화(Synchronized) 지원 List 인터페이스를 구현한 클래스(요소에 순서가 있고, 중복 허용) 내부적으로 모든 메서드가 동기화되어 있어, 멀티스레드 환경에서 안전하게 사용할 수 있음 하지만 오늘날에는 ArrayList와 Collections.synchronizedList() 조합을 더 많이 사용 [예시] Vector\nVector\u0026lt;String\u0026gt; vector = new Vector\u0026lt;\u0026gt;(); vector.add(\u0026quot;apple\u0026quot;); vector.add(\u0026quot;banana\u0026quot;); System.out.println(vector); // [apple, banana] Stack LIFO(Last In First Out, 후입선출) 구조의 자료구조 Vector 클래스를 상속받아 구현됨 push(), pop(), peek() 등 스택 연산 지원 현재는 Deque 인터페이스(예: ArrayDeque)를 사용하는 것을 권장 [예시] Stack\nStack\u0026lt;String\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(\u0026quot;apple\u0026quot;); stack.push(\u0026quot;banana\u0026quot;); System.out.println(stack.pop()); // banana Hashtable Key-Value 쌍을 저장하는 해시 기반의 자료구조 동기화(Synchronized) 지원 Map 인터페이스를 구현한 클래스(키는 중복 불가, 값은 중복 가능) 현재는 HashMap과 ConcurrentHashMap이 더 많이 사용 [예시] Hashtable\nHashtable\u0026lt;String, Integer\u0026gt; table = new Hashtable\u0026lt;\u0026gt;(); table.put(\u0026quot;apple\u0026quot;, 1); table.put(\u0026quot;banana\u0026quot;, 2); System.out.println(table.get(\u0026quot;apple\u0026quot;)); // 1 문제점 성능 저하: 내부적으로 모든 메서드가 동기화되어 있어, 단일 스레드 환경에서는 불필요한 성능 저하가 발생할 수 있음 기능 제한: 컬렉션 프레임워크의 다양한 인터페이스와 기능을 지원하지 않음 유지보수 어려움: 레거시 코드는 최신 코드와 호환성이 떨어질 수 있음 대안 Vector → ArrayList 동기화가 필요하다면 Collections.synchronizedList(new ArrayList\u0026lt;\u0026gt;()) 사용 Stack → ArrayDeque ArrayDeque는 스택과 큐 모두로 활용 가능 Hashtable → HashMap 동기화가 필요하다면 ConcurrentHashMap 사용 ✅ 결론: 컬렉션 프레임워크의 ArrayList, ArrayDeque, HashMap, ConcurrentHashMap 사용을 권장합니다.\n🤔 Collection과 Collections의 차이는 무엇일까? Collections는 데이터를 담는 컨테이너가 아니라 컨테이너(List, Set, Map 등)를 조작하거나 생성하는 유틸 메서드 묶음 (쉽게 표현하자면 도구 상자⚒️)입니다.\nimport java.util.Collection;을 통해 사용할 수 있습니다.\n[예시] Collections를 import해서 sort 메서드 사용\nimport java.util.Collections; List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026quot;C\u0026quot;, \u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;); Collections.sort(list); ✅ 즉, Collection은 컨테이너 모음, Collections는 컨테이너를 다루기 위한 도구 모음 패키지\n🤔 Map은 Iterable할까? 자바에서 Map 인터페이스는 Iterable을 직접 구현하지 않습니다.\n즉, Map 객체 자체로는 iterator() 메서드를 직접 호출할 수 없습니다.\nMap은 Collection 계층이 아닌 별의 인터페이스이자 key-value 쌍을 저장하는 구조이기 때문입니다.\n하지만 Map의 key, value, 또는 entry(키-값 쌍)를 Set이나 Collection 형태로 얻어온 후에는 Iterable을 사용할 수 있습니다.\n예를 들어,\nmap.keySet(): 키들의 집합(Set) 반환 → Iterable map.values(): 값들의 집합(Collection) 반환 → Iterable map.entrySet(): 키-값 쌍의 집합(Set) 반환 → Iterable 이렇게 얻은 Set이나 Collection 객체는 Iterable을 구현하므로, for-each문이나 Iterator를 사용해 순회할 수 있습니다.\n[예시] Map으로부터 Iterable한 entrySet을 만든 경우\nimport java.util.Map; import java.util.HashMap; import java.util.Iterator; import java.util.Set; import java.util.Map.Entry; public class MapIterationExample { public static void main(String[] args) { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026quot;apple\u0026quot;, 1); map.put(\u0026quot;banana\u0026quot;, 2); map.put(\u0026quot;orange\u0026quot;, 3); // 1. for-each 루프로 entrySet 순회 for (Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { System.out.println(\u0026quot;Key: \u0026quot; + entry.getKey() + \u0026quot;, Value: \u0026quot; + entry.getValue()); } // 2. Iterator로 entrySet 순회 Set\u0026lt;Entry\u0026lt;String, Integer\u0026gt;\u0026gt; entrySet = map.entrySet(); Iterator\u0026lt;Entry\u0026lt;String, Integer\u0026gt;\u0026gt; entryIterator = entrySet.iterator(); while (entryIterator.hasNext()) { Entry\u0026lt;String, Integer\u0026gt; entry = entryIterator.next(); System.out.println(\u0026quot;Key: \u0026quot; + entry.getKey() + \u0026quot;, Value: \u0026quot; + entry.getValue()); } } } ✅ 결론: Map 자체는 Iterable이 아니지만, entrySet() 등으로 얻은 Set 객체는 Iterable합니다.\ncf) C++의 std::map은 직접적으로 “Iterable”이라는 인터페이스를 구현하는 것은 아니지만, STL 컨테이너들은 모두 반복자(iterator)를 제공하여 순회가 가능합니다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; int main() { std::map\u0026lt;std::string, int\u0026gt; myMap; myMap[\u0026quot;apple\u0026quot;] = 1; myMap[\u0026quot;banana\u0026quot;] = 2; myMap[\u0026quot;orange\u0026quot;] = 3; // 범위 기반 for문 (C++11 이상) for (const auto\u0026amp; pair : myMap) { std::cout \u0026lt;\u0026lt; \u0026quot;Key: \u0026quot; \u0026lt;\u0026lt; pair.first \u0026lt;\u0026lt; \u0026quot;, Value: \u0026quot; \u0026lt;\u0026lt; pair.second \u0026lt;\u0026lt; std::endl; } // 반복자를 이용한 순회 for (auto iter = myMap.begin(); iter != myMap.end(); ++iter) { std::cout \u0026lt;\u0026lt; \u0026quot;Key: \u0026quot; \u0026lt;\u0026lt; iter-\u0026gt;first \u0026lt;\u0026lt; \u0026quot;, Value: \u0026quot; \u0026lt;\u0026lt; iter-\u0026gt;second \u0026lt;\u0026lt; std::endl; } } 즉, Java의 Map과 다르게 별도의 변환이 없어도 C++의 map은 iterator나 범위 기반 for문을 통해 직접 순회가 가능하기 때문에 실질적으로 iterable하다고 할 수 있습니다. 🤩\n글을 마치며 각 컬렉션 및 타입들의 주요 특징을 이해하면, 상황에 맞는 효율적인 코드를 쉽고 빠르게 작성할 수 있습니다. 공부한 내용을 정리하다 보니 글에 부족한 부분이나 잘못된 내용이 있을 수 있습니다. 잘못된 점이나 보완하면 좋을 점, 또는 궁금한 점이 있다면 언제든 댓글로 남겨주세요!\n👀 Reference C++과 Java를 비교하면서 설명하는 좋은 블로그를 발견해서 링크를 함께 남깁니다 :)\nOrientation: https://justkode.kr/java/cpp-to-java-0/ Collecionts: https://justkode.kr/java/cpp-to-java-8/ ","permalink":"http://yeniful.github.io/posts/20250614/","summary":"\u003cp\u003e최근 C++과 Java 두 언어를 살펴보면서 자료구조 라이브러리(각각 STL과 컬렉션 프레임워크)에서 느껴지는 차이점이 흥미로웠습니다. 🤩\n언어별로 용어가 다르거나 인터페이스가 달라 헷갈리는 경우도 있었고, 알게된 것들을 더 잘 기억하기 위해 Java의 컬렉션(Collection) 프레임워크에 대해 간단하게 정리해보겠습니다 :)\u003c/p\u003e\n\u003ch2 id=\"collection이란\"\u003eCollection이란?\u003c/h2\u003e\n\u003cp\u003eJava에서 \u003cstrong\u003e컬렉션(Collection)\u003c/strong\u003e 은 데이터(객체)를 담고 관리하는 그릇, 즉 컨테이너(container) 역할을 하는 패키지입니다.\n자바의 컨테이너는 크게 \u003ccode\u003eList\u003c/code\u003e 계열, \u003ccode\u003eSet\u003c/code\u003e 계열, \u003ccode\u003eMap\u003c/code\u003e 계열 3가지로 구분할 수 있어요.\u003c/p\u003e\n\u003cp\u003e주의해야할 점은, \u003ccode\u003eList\u003c/code\u003e 와 \u003ccode\u003eSet\u003c/code\u003e 은 Collection의 하위 인터페이스지만 \u003ccode\u003eMap\u003c/code\u003e 은 둘과 구분되는 인터페이스라는 것입니다.\n\u003ccode\u003eMap\u003c/code\u003e 은 Collection이 아니지만, Collection과 마찬가지로 데이터를 담는 역할을 하는 친구이기 때문에 함께 정리할게요.\u003c/p\u003e","title":"[Java] Java의 Collection Framework (컬렉션 프레임워크)를 알아보자!"},{"content":"\n다시 돌아온 깃허브 블로그 반가워요 👋 안녕하세요, 예니입니다-! 👻 (주섬주섬 이사떡을 꺼낸다)\n작년부터 Medium에서 글쓰기를 다시 시작하기도 했고, 기록에 대한 중요성을 느껴서 기술 블로그를 다시 운영해보려고 합니다. 오래 전부터 깃허브 블로그 운영을 여러 차례 시도했지만, 매번 손을 놓아버리게 되었어요. (꾸밀 때만 열심히 \u0026hellip;🎨) (예쁜 디자인 다 필요 없고 일단 기본 테마로 꾸준히 써보라는 개발자 M님의 조언을 다시 한 번 되새겨봅니다)\n티스토리와 Velog, 여러 해외 개발자 블로그 플랫폼 그리고 미디움을 거쳐서 다시 돌아오게 되었는데요. DevTO, Hashnode, Substack 등 WordPress나 Wix같이 유료 서비스 빼고 거의 다 써봤는데 정착하고 싶은 곳이 정말정말 없더라구요. 🥲 무엇보다도 많은 서비스들이 빠르게 생기고, 빠르게 사라지기에 안정적인 플랫폼을 선택하고 싶었어요.\nHugo 기존에 사용했던 정적 페이지 생성기 Jekyll을 사용하려고 했으나, 루비 세팅도 번거롭고 (Rosetta 이슈가 아직도 있다는 무시무시한 전설이) Jekyll 말고 다른 도구도 사용해보고싶은 마음에 이번에는 Hugo를 선택하게 되었어요.\nHugo는 \u0026ldquo;세상에서 제일 빠른 웹 사이트 생성 프레임워크\u0026quot;라는 캐치프라이즈로 서비스를 소개하고 있는데요, 이름에서 슬쩍 눈치챌 수 있듯이 언어 \u0026lsquo;Go\u0026rsquo; (고랭)으로 만들어졌다고 해요. 이름 정말 잘 지었죠? Hugo 둘러보기 테마도 다양하고, 최근까지 업데이트가 계속된 테마들이 많아서 놀랐어요. Hugo Theme 둘러보기 그리고 quick start 튜토리얼을 따라 차근차근 해보니 세팅이 까다롭지 않았어요. (Theme은 아주 심플하게 튜토리얼에서 사용하고 있는 ananke를 선택했답니다. 기능 추가에 어려움이 있어서 PaperMod로 변경 - 2025.6.11)\n지속가능한 테크 블로깅을 꿈꾸며, 오늘의 글은 이만 마무리 해볼게요. 자주 만나요~ 제~ 발~\n","permalink":"http://yeniful.github.io/posts/20250425/","summary":"\u003cp\u003e\u003cimg alt=\"이사떡\" loading=\"lazy\" src=\"/images/Sirutteok.jpg\"\u003e\u003c/p\u003e\n\u003ch3 id=\"다시-돌아온-깃허브-블로그-반가워요-\"\u003e다시 돌아온 깃허브 블로그 반가워요 👋\u003c/h3\u003e\n\u003cp\u003e안녕하세요, 예니입니다-! 👻 (주섬주섬 이사떡을 꺼낸다)\u003c/p\u003e\n\u003cp\u003e작년부터 Medium에서 글쓰기를 다시 시작하기도 했고, 기록에 대한 중요성을 느껴서 기술 블로그를 다시 운영해보려고 합니다.\n오래 전부터 깃허브 블로그 운영을 여러 차례 시도했지만, 매번 손을 놓아버리게 되었어요. (꾸밀 때만 열심히 \u0026hellip;🎨)  (예쁜 디자인 다 필요 없고 일단 기본 테마로 꾸준히 써보라는 개발자 M님의 조언을 다시 한 번 되새겨봅니다)\u003c/p\u003e\n\u003cp\u003e티스토리와 Velog, 여러 해외 개발자 블로그 플랫폼 그리고 미디움을 거쳐서 다시 돌아오게 되었는데요. DevTO, Hashnode, Substack 등 WordPress나 Wix같이 유료 서비스 빼고 거의 다 써봤는데 정착하고 싶은 곳이 정말정말 없더라구요. 🥲 무엇보다도 많은 서비스들이 빠르게 생기고, 빠르게 사라지기에 안정적인 플랫폼을 선택하고 싶었어요.\u003c/p\u003e","title":"똑똑똑, 이사왔어요~ 🛻💨"}]