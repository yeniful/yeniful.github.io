<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[SwiftUI] struct View vs @ViewBuilder 함수, 뭐가 다를까? | @yeniful blog</title><meta name=keywords content="SwiftUI,iOS"><meta name=description content="모티베이션

&ldquo;재사용되는 View를 구조체로 빼야 하나, 아니면 그냥 함수로 만들어도 될까?&rdquo;

View를 만들 때 특별한 기준 없이 View를 만들 때 습관적으로 구조체를 만들거나, 간단한 건 함수로 처리하곤 했는데요. 앱의 구조와 성능, 유지보수 방식에 꽤 중요한 영향을 준다는 것을 알게 되었고, 간단한 내용이지만 한 번 정리해보고 싶었습니다.
그래서 이번 글에서는 Apple 공식 문서와 WWDC 세션에서 강조한 원리를 바탕으로 struct View vs. @ViewBuilder 함수의 차이를 정리해보려고 합니다.

두 가지 방식 살펴보기
먼저 동일한 UI를 두 가지 방식으로 만들어봤습니다."><meta name=author content><link rel=canonical href=http://yeniful.github.io/posts/2025/20250301_swiftuiview/><link crossorigin=anonymous href=/assets/css/stylesheet.bf2d02fd8e0e6965923fbe8335c9e2405fb13a13153d3d34fd97cede7c145ec2.css integrity="sha256-vy0C/Y4OaWWSP76DNcniQF+xOhMVPT00/ZfO3nwUXsI=" rel="preload stylesheet" as=style><link rel=icon href=http://yeniful.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://yeniful.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://yeniful.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://yeniful.github.io/apple-touch-icon.png><link rel=mask-icon href=http://yeniful.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://yeniful.github.io/posts/2025/20250301_swiftuiview/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://yeniful.github.io/posts/2025/20250301_swiftuiview/"><meta property="og:site_name" content="@yeniful blog"><meta property="og:title" content="[SwiftUI] struct View vs @ViewBuilder 함수, 뭐가 다를까?"><meta property="og:description" content="모티베이션 “재사용되는 View를 구조체로 빼야 하나, 아니면 그냥 함수로 만들어도 될까?”
View를 만들 때 특별한 기준 없이 View를 만들 때 습관적으로 구조체를 만들거나, 간단한 건 함수로 처리하곤 했는데요. 앱의 구조와 성능, 유지보수 방식에 꽤 중요한 영향을 준다는 것을 알게 되었고, 간단한 내용이지만 한 번 정리해보고 싶었습니다.
그래서 이번 글에서는 Apple 공식 문서와 WWDC 세션에서 강조한 원리를 바탕으로 struct View vs. @ViewBuilder 함수의 차이를 정리해보려고 합니다.
두 가지 방식 살펴보기 먼저 동일한 UI를 두 가지 방식으로 만들어봤습니다."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-01T00:00:00+09:00"><meta property="article:modified_time" content="2025-03-01T00:00:00+09:00"><meta property="article:tag" content="SwiftUI"><meta property="article:tag" content="IOS"><meta name=twitter:card content="summary"><meta name=twitter:title content="[SwiftUI] struct View vs @ViewBuilder 함수, 뭐가 다를까?"><meta name=twitter:description content="모티베이션

&ldquo;재사용되는 View를 구조체로 빼야 하나, 아니면 그냥 함수로 만들어도 될까?&rdquo;

View를 만들 때 특별한 기준 없이 View를 만들 때 습관적으로 구조체를 만들거나, 간단한 건 함수로 처리하곤 했는데요. 앱의 구조와 성능, 유지보수 방식에 꽤 중요한 영향을 준다는 것을 알게 되었고, 간단한 내용이지만 한 번 정리해보고 싶었습니다.
그래서 이번 글에서는 Apple 공식 문서와 WWDC 세션에서 강조한 원리를 바탕으로 struct View vs. @ViewBuilder 함수의 차이를 정리해보려고 합니다.

두 가지 방식 살펴보기
먼저 동일한 UI를 두 가지 방식으로 만들어봤습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://yeniful.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[SwiftUI] struct View vs @ViewBuilder 함수, 뭐가 다를까?","item":"http://yeniful.github.io/posts/2025/20250301_swiftuiview/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[SwiftUI] struct View vs @ViewBuilder 함수, 뭐가 다를까?","name":"[SwiftUI] struct View vs @ViewBuilder 함수, 뭐가 다를까?","description":"모티베이션 \u0026ldquo;재사용되는 View를 구조체로 빼야 하나, 아니면 그냥 함수로 만들어도 될까?\u0026rdquo;\nView를 만들 때 특별한 기준 없이 View를 만들 때 습관적으로 구조체를 만들거나, 간단한 건 함수로 처리하곤 했는데요. 앱의 구조와 성능, 유지보수 방식에 꽤 중요한 영향을 준다는 것을 알게 되었고, 간단한 내용이지만 한 번 정리해보고 싶었습니다.\n그래서 이번 글에서는 Apple 공식 문서와 WWDC 세션에서 강조한 원리를 바탕으로 struct View vs. @ViewBuilder 함수의 차이를 정리해보려고 합니다.\n두 가지 방식 살펴보기 먼저 동일한 UI를 두 가지 방식으로 만들어봤습니다.\n","keywords":["SwiftUI","iOS"],"articleBody":"모티베이션 “재사용되는 View를 구조체로 빼야 하나, 아니면 그냥 함수로 만들어도 될까?”\nView를 만들 때 특별한 기준 없이 View를 만들 때 습관적으로 구조체를 만들거나, 간단한 건 함수로 처리하곤 했는데요. 앱의 구조와 성능, 유지보수 방식에 꽤 중요한 영향을 준다는 것을 알게 되었고, 간단한 내용이지만 한 번 정리해보고 싶었습니다.\n그래서 이번 글에서는 Apple 공식 문서와 WWDC 세션에서 강조한 원리를 바탕으로 struct View vs. @ViewBuilder 함수의 차이를 정리해보려고 합니다.\n두 가지 방식 살펴보기 먼저 동일한 UI를 두 가지 방식으로 만들어봤습니다.\n구조체 View로 분리\nstruct ProfileCard: View { let name: String let role: String var body: some View { VStack(alignment: .leading, spacing: 8) { Text(name) .font(.headline) Text(role) .font(.subheadline) .foregroundColor(.secondary) } .padding() .background(Color(.systemBackground)) .cornerRadius(12) } } // 사용 ProfileCard(name: \"예니\", role: \"iOS Developer\") 함수로 분리\n@ViewBuilder func profileCard(name: String, role: String) -\u003e some View { VStack(alignment: .leading, spacing: 8) { Text(name) .font(.headline) Text(role) .font(.subheadline) .foregroundColor(.secondary) } .padding() .background(Color(.systemBackground)) .cornerRadius(12) } // 사용 profileCard(name: \"예니\", role: \"iOS Developer\") 겉보기에 유사해 보이지만, SwiftUI 내부에서는 이 둘을 다르게 처리합니다.\n6가지 차이 1. 상태(State)를 가질 수 있는가 SwiftUI에서 상태(@State, @Binding, @StateObject)는 View의 identity와 lifetime에 연결되는 값입니다.\n그리고 SwiftUI는 구조체로 만든 View에만 이러한 상태 저장소를 생성합니다. 즉, 상태는 View 구조체 내부에서만 선언할 수 있습니다.\nstruct ExpandableCard: View { let title: String @State private var isExpanded = false // ✅ 자체 상태 보유 var body: some View { VStack { Button(title) { isExpanded.toggle() } if isExpanded { Text(\"상세 내용입니다\") } } } } 반면 함수는 identity가 없으므로 자체 상태 저장소를 가질 수 없습니다. 상태가 필요하다면 부모 View에서 관리하고 Binding으로 넘겨받아야 합니다. (identity에 대해서는 다음 항목에서 설명하겠습니다.)\n// 함수는 자체 @State를 가질 수 없음 @ViewBuilder func expandableCard(title: String, isExpanded: Binding) -\u003e some View { VStack { Button(title) { isExpanded.wrappedValue.toggle() } if isExpanded.wrappedValue { Text(\"상세 내용입니다\") } } } 즉, struct View는 SwiftUI가 관리하는 state storage를 갖고 있지만, 함수 기반 View는 갖고 있지 않아서 state를 가질 수 없습니다.\n2. View Identity WWDC21의 Demystify SwiftUI 에서 SwiftUI의 핵심 원리로 세 가지를 소개합니다\nIdentity Lifetime Dependencies 여기서 Identity는 다음을 의미합니다:\n“Identity is how SwiftUI recognizes elements as the same or distinct across multiple updates of your app.”\n즉, Identity란 SwiftUI가 앱의 여러 업데이트에서 요소를 같은 것 또는 다른 것으로 인식하는 방식입니다.\nSwiftUI는 두 가지 방식으로 View를 식별합니다.\nExplicit Identity : 개발자가 직접 제공하는 식별자 (예: ForEach의 id, .id() modifier) Structural Identity : View의 타입과 계층 구조 내 위치로 암묵적으로 부여되는 식별자 구조체로 만든 View는 고유한 타입이 있기 때문에 identity가 있습니다. 즉, SwiftUI는 구조체로 만든 View에 명확한 structural identity를 부여합니다.\n따라서 SwiftUI는 “이 ProfileCard는 이전에 있던 같은 ProfileCard다.“를 인식합니다.\nstruct ParentView: View { @State private var count = 0 var body: some View { VStack { Text(\"Count: \\(count)\") Button(\"증가\") { count += 1 } // 고유 identity를 가지는 ProfileCard ProfileCard(name: \"김개발\", role: \"iOS\") } } } 하지만 함수로 만든 View는 매 렌더링마다 “새로 구성된 View\"로 취급됩니다.\nIdentity는 직전에 설명드린 State와도 관련이 있습니다. WWDC21 세션에서는 State와 Identity의 관계를 명확히 설명합니다:\nSwiftUI가 View를 보고 State나 StateObject를 발견하면, 해당 데이터를 View의 lifetime 동안 유지해야 한다는 것을 인지합니다.\n“When SwiftUI is looking at your view and sees a State or a StateObject, it knows that it needs to persist that piece of data throughout the view’s lifetime.”\nState의 지속성(Persistence)은 View의 lifetime에 연결되어 있습니다.\n“The persistence of your state is tied to the lifetime of your views.”\n구조체로 만든 View와 달리 함수로 만든 View는 단순히 View를 반환하는 코드일 뿐, 별도의 identity를 형성하지 않습니다. 함수를 호출하는 부모 View가 다시 그려질 때마다 함수도 재호출됩니다.\n3. @ViewBuilder의 역할 ViewBuilder 문서에 따르면, ViewBuilder는 “클로저로부터 View를 구성하는 커스텀 파라미터 속성\"입니다. WWDC 세션에서는 함수에 @ViewBuilder를 적용하는 방법도 소개합니다:\n“Swift does not infer helper functions to be view builders by default, but we can opt into that by manually applying the ViewBuilder attribute ourselves.”\n하지만 @ViewBuilder를 함수에 적용해도 해당 함수가 구조체 View와 동일한 identity를 갖게 되는 것은 아닙니다. ViewBuilder는 단지 여러 View를 조합할 수 있게 해주는 문법적 편의 기능일 뿐입니다.\n4. AnyView 회피와 성능 WWDC21 세션에서는 AnyView의 과도한 사용을 피하라고 권고합니다\n“In general, we recommend avoiding AnyViews whenever possible. Having too many AnyViews will often make code harder to read and understand… And because AnyView hides static type information from the compiler, it can sometimes prevent helpful diagnostic errors and warnings from being surfaced in your code. Finally, keep in mind that using AnyView when you don’t need to can result in worse performance.”\n함수에서 여러 타입의 View를 반환하려면 AnyView로 감싸거나 @ViewBuilder를 사용해야 합니다. 구조체를 사용하면 각 View가 명확한 타입을 가지므로 이러한 문제를 피할 수 있습니다.\n5. View Life Cycle 함수로 반환한 View에도 onAppear, onDisappear, task 같은 생명주기 modifier를 붙일 수는 있습니다. 하지만 함수는 독립적인 identity가 없으므로, 해당 modifier는 부모 View의 생명주기를 따르게 됩니다.\n반면 구조체는 자체적인 identity와 lifetime을 가지므로, 생명주기 modifier가 해당 View의 등장/퇴장 시점에 정확히 동작합니다.\nstruct DataFetchingView: View { @State private var data: [Item] = [] var body: some View { List(data) { item in Text(item.name) } .onAppear { // View가 나타날 때 데이터 로드 } .task { // 비동기 작업 수행 } } } 정리: 언제 무엇을 선택할까 상황 선택 근거 자체 상태(@State 등)가 필요할 때 구조체 함수는 상태를 가질 수 없음 여러 화면에서 재사용할 컴포넌트 구조체 독립적인 identity와 타입으로 관리 가능 onAppear, task 등 생명주기 활용 구조체 의미 있는 lifetime 보장 복잡한 로직이 포함된 View 구조체 명확한 identity로 성능 최적화 같은 View 내에서 단순 중복 제거 함수 빠르고 간편함 상태 없는 아주 작은 UI 조각 함수 오버헤드 없이 간단히 처리 결론 기본적으로 구조체 친화적인 SwiftUI는 View를 만들 때 구조체 사용을 권장합니다. 그리고 상황적으로 유연하게 함수로 View를 그리는 것이 가능합니다.\n재사용·확장성·상태·생명주기가 필요하다 → struct 한 화면 안에서의 작은 UI 조각 → 함수 SwiftUI는 Identity, Lifetime, Dependencies라는 원리를 기반으로 작동하는데요, 이 관점에서 보면 struct View는 SwiftUI가 기대하는 방식에 자연스럽게 맞춰져 있고, 함수 기반 View는 역할이 제한적입니다.\n함수는 “같은 View 안에서 반복되는 작은 UI 조각을 빠르게 추출\"하는 용도로 제한적으로 사용하면 좋습니다. 만약 함수가 점점 복잡해지거나, 상태가 필요해지거나, 다른 곳에서도 쓰이게 된다면 그때 구조체로 승격시키면 됩니다.\n참고 자료 WWDC21: Demystify SwiftUI Apple Developer Documentation: View Apple Developer Documentation: State Apple Developer Documentation: ViewBuilder WWDC24: SwiftUI essentials ","wordCount":"978","inLanguage":"en","datePublished":"2025-03-01T00:00:00+09:00","dateModified":"2025-03-01T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://yeniful.github.io/posts/2025/20250301_swiftuiview/"},"publisher":{"@type":"Organization","name":"@yeniful blog","logo":{"@type":"ImageObject","url":"http://yeniful.github.io/favicon.ico"}}}</script></head><body class=simple-mode id=top><header class=header><nav class=nav><div class=logo><a href=http://yeniful.github.io/ accesskey=h title="@yeniful blog (Alt + H)">@yeniful blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://yeniful.github.io/ title=Home><span>Home</span></a></li><li><a href=http://yeniful.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=http://yeniful.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://yeniful.github.io/notice/ title=Notice><span>Notice</span></a></li><li><a href=http://yeniful.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[SwiftUI] struct View vs @ViewBuilder 함수, 뭐가 다를까?</h1><div class=post-meta><span title='2025-03-01 00:00:00 +0900 +0900'>March 1, 2025</span>&nbsp;·&nbsp;<span>5 min</span></div></header><div class=post-content><h2 id=모티베이션>모티베이션<a hidden class=anchor aria-hidden=true href=#모티베이션>#</a></h2><blockquote><p>&ldquo;재사용되는 View를 구조체로 빼야 하나, 아니면 그냥 함수로 만들어도 될까?&rdquo;</p></blockquote><p>View를 만들 때 특별한 기준 없이 View를 만들 때 습관적으로 구조체를 만들거나, 간단한 건 함수로 처리하곤 했는데요. 앱의 구조와 성능, 유지보수 방식에 꽤 중요한 영향을 준다는 것을 알게 되었고, 간단한 내용이지만 한 번 정리해보고 싶었습니다.</p><p>그래서 이번 글에서는 Apple 공식 문서와 WWDC 세션에서 강조한 원리를 바탕으로 <strong>struct View vs. @ViewBuilder 함수</strong>의 차이를 정리해보려고 합니다.</p><hr><h2 id=두-가지-방식-살펴보기>두 가지 방식 살펴보기<a hidden class=anchor aria-hidden=true href=#두-가지-방식-살펴보기>#</a></h2><p>먼저 동일한 UI를 두 가지 방식으로 만들어봤습니다.</p><p><strong>구조체 View로 분리</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ProfileCard</span>: View {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> name: String
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> role: String
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some View {
</span></span><span style=display:flex><span>        VStack(alignment: .leading, spacing: <span style=color:#ae81ff>8</span>) {
</span></span><span style=display:flex><span>            Text(name)
</span></span><span style=display:flex><span>                .font(.headline)
</span></span><span style=display:flex><span>            Text(role)
</span></span><span style=display:flex><span>                .font(.subheadline)
</span></span><span style=display:flex><span>                .foregroundColor(.secondary)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        .padding()
</span></span><span style=display:flex><span>        .background(Color(.systemBackground))
</span></span><span style=display:flex><span>        .cornerRadius(<span style=color:#ae81ff>12</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 사용</span>
</span></span><span style=display:flex><span>ProfileCard(name: <span style=color:#e6db74>&#34;예니&#34;</span>, role: <span style=color:#e6db74>&#34;iOS Developer&#34;</span>)
</span></span></code></pre></div><p><strong>함수로 분리</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-swift data-lang=swift><span style=display:flex><span>@ViewBuilder
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>profileCard</span>(name: String, role: String) -&gt; some View {
</span></span><span style=display:flex><span>    VStack(alignment: .leading, spacing: <span style=color:#ae81ff>8</span>) {
</span></span><span style=display:flex><span>        Text(name)
</span></span><span style=display:flex><span>            .font(.headline)
</span></span><span style=display:flex><span>        Text(role)
</span></span><span style=display:flex><span>            .font(.subheadline)
</span></span><span style=display:flex><span>            .foregroundColor(.secondary)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    .padding()
</span></span><span style=display:flex><span>    .background(Color(.systemBackground))
</span></span><span style=display:flex><span>    .cornerRadius(<span style=color:#ae81ff>12</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 사용</span>
</span></span><span style=display:flex><span>profileCard(name: <span style=color:#e6db74>&#34;예니&#34;</span>, role: <span style=color:#e6db74>&#34;iOS Developer&#34;</span>)
</span></span></code></pre></div><p>겉보기에 유사해 보이지만, SwiftUI 내부에서는 이 둘을 다르게 처리합니다.</p><hr><h2 id=6가지-차이>6가지 차이<a hidden class=anchor aria-hidden=true href=#6가지-차이>#</a></h2><h3 id=1-상태state를-가질-수-있는가>1. 상태(State)를 가질 수 있는가<a hidden class=anchor aria-hidden=true href=#1-상태state를-가질-수-있는가>#</a></h3><p>SwiftUI에서 상태(@State, @Binding, @StateObject)는
<strong>View의 identity와 lifetime에 연결되는 값</strong>입니다.</p><p>그리고 SwiftUI는 <strong>구조체로 만든 View에만</strong> 이러한 상태 저장소를 생성합니다.
즉, 상태는 <strong>View 구조체 내부에서만 선언할 수 있습니다.</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ExpandableCard</span>: View {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> title: String
</span></span><span style=display:flex><span>    @State <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> isExpanded = <span style=color:#66d9ef>false</span>  <span style=color:#75715e>// ✅ 자체 상태 보유</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some View {
</span></span><span style=display:flex><span>        VStack {
</span></span><span style=display:flex><span>            Button(title) {
</span></span><span style=display:flex><span>                isExpanded.toggle()
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> isExpanded {
</span></span><span style=display:flex><span>                Text(<span style=color:#e6db74>&#34;상세 내용입니다&#34;</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>반면 <strong>함수</strong>는 identity가 없으므로 자체 상태 저장소를 가질 수 없습니다.
상태가 필요하다면 부모 View에서 관리하고 <strong>Binding</strong>으로 넘겨받아야 합니다.
(identity에 대해서는 다음 항목에서 설명하겠습니다.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// 함수는 자체 @State를 가질 수 없음</span>
</span></span><span style=display:flex><span>@ViewBuilder
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>expandableCard</span>(title: String, isExpanded: Binding&lt;Bool&gt;) -&gt; some View {
</span></span><span style=display:flex><span>    VStack {
</span></span><span style=display:flex><span>        Button(title) {
</span></span><span style=display:flex><span>            isExpanded.wrappedValue.toggle()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> isExpanded.wrappedValue {
</span></span><span style=display:flex><span>            Text(<span style=color:#e6db74>&#34;상세 내용입니다&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>즉, struct View는 SwiftUI가 관리하는 state storage를 갖고 있지만,
함수 기반 View는 갖고 있지 않아서 state를 가질 수 없습니다.</p><h3 id=2-view-identity>2. View Identity<a hidden class=anchor aria-hidden=true href=#2-view-identity>#</a></h3><p>WWDC21의 <a href=https://developer.apple.com/videos/play/wwdc2021/10022/>Demystify SwiftUI</a> 에서 SwiftUI의 핵심 원리로 세 가지를 소개합니다</p><ul><li><em><strong>Identity</strong></em></li><li><em><strong>Lifetime</strong></em></li><li><em><strong>Dependencies</strong></em></li></ul><p>여기서 Identity는 다음을 의미합니다:</p><blockquote><p>&ldquo;Identity is how SwiftUI recognizes elements as the same or distinct across multiple updates of your app.&rdquo;</p></blockquote><p>즉, Identity란 SwiftUI가 앱의 여러 업데이트에서 <strong>요소를 같은 것 또는 다른 것으로 인식하는 방식</strong>입니다.</p><p>SwiftUI는 두 가지 방식으로 View를 식별합니다.</p><ul><li><em><strong>Explicit Identity</strong></em> : 개발자가 직접 제공하는 식별자 (예: <code>ForEach</code>의 <code>id</code>, <code>.id()</code> modifier)</li><li><em><strong>Structural Identity</strong></em> : <strong>View의 타입</strong>과 계층 구조 내 위치로 암묵적으로 부여되는 식별자</li></ul><p><strong>구조체</strong>로 만든 View는 고유한 타입이 있기 때문에 identity가 있습니다.
즉, SwiftUI는 구조체로 만든 View에 명확한 structural identity를 부여합니다.</p><p>따라서 SwiftUI는 &ldquo;이 ProfileCard는 이전에 있던 같은 ProfileCard다.&ldquo;를 인식합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ParentView</span>: View {
</span></span><span style=display:flex><span>    @State <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> count = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some View {
</span></span><span style=display:flex><span>        VStack {
</span></span><span style=display:flex><span>            Text(<span style=color:#e6db74>&#34;Count: </span><span style=color:#e6db74>\(</span>count<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>            Button(<span style=color:#e6db74>&#34;증가&#34;</span>) { count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span> }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 고유 identity를 가지는 ProfileCard</span>
</span></span><span style=display:flex><span>            ProfileCard(name: <span style=color:#e6db74>&#34;김개발&#34;</span>, role: <span style=color:#e6db74>&#34;iOS&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>하지만 <strong>함수</strong>로 만든 View는 매 렌더링마다 &ldquo;새로 구성된 View"로 취급됩니다.</p><p>Identity는 직전에 설명드린 State와도 관련이 있습니다.
WWDC21 세션에서는 State와 Identity의 관계를 명확히 설명합니다:</p><p>SwiftUI가 View를 보고 State나 StateObject를 발견하면, 해당 데이터를 View의 lifetime 동안 유지해야 한다는 것을 인지합니다.</p><blockquote><p>&ldquo;When SwiftUI is looking at your view and sees a State or a StateObject, it knows that it needs to persist that piece of data throughout the view&rsquo;s lifetime.&rdquo;</p></blockquote><p>State의 지속성(Persistence)은 View의 lifetime에 연결되어 있습니다.</p><blockquote><p>&ldquo;The persistence of your state is tied to the lifetime of your views.&rdquo;</p></blockquote><p>구조체로 만든 View와 달리 함수로 만든 View는 단순히 View를 반환하는 코드일 뿐,
별도의 identity를 형성하지 않습니다.
함수를 호출하는 부모 View가 다시 그려질 때마다 함수도 재호출됩니다.</p><h3 id=3-viewbuilder의-역할>3. @ViewBuilder의 역할<a hidden class=anchor aria-hidden=true href=#3-viewbuilder의-역할>#</a></h3><p><a href=https://developer.apple.com/documentation/swiftui/viewbuilder>ViewBuilder 문서</a>에 따르면, ViewBuilder는 &ldquo;클로저로부터 View를 구성하는 커스텀 파라미터 속성"입니다.
WWDC 세션에서는 함수에 <code>@ViewBuilder</code>를 적용하는 방법도 소개합니다:</p><blockquote><p>&ldquo;Swift does not infer helper functions to be view builders by default, but we can opt into that by manually applying the ViewBuilder attribute ourselves.&rdquo;</p></blockquote><p>하지만 <code>@ViewBuilder</code>를 함수에 적용해도 해당 함수가 구조체 View와 동일한 identity를 갖게 되는 것은 아닙니다. ViewBuilder는 단지 여러 View를 조합할 수 있게 해주는 문법적 편의 기능일 뿐입니다.</p><h3 id=4-anyview-회피와-성능>4. AnyView 회피와 성능<a hidden class=anchor aria-hidden=true href=#4-anyview-회피와-성능>#</a></h3><p>WWDC21 세션에서는 <code>AnyView</code>의 과도한 사용을 피하라고 권고합니다</p><blockquote><p>&ldquo;In general, we recommend avoiding AnyViews whenever possible. Having too many AnyViews will often make code harder to read and understand&mldr; And because AnyView hides static type information from the compiler, it can sometimes prevent helpful diagnostic errors and warnings from being surfaced in your code. Finally, keep in mind that using AnyView when you don&rsquo;t need to can result in worse performance.&rdquo;</p></blockquote><p>함수에서 여러 타입의 View를 반환하려면 <code>AnyView</code>로 감싸거나 <code>@ViewBuilder</code>를 사용해야 합니다. 구조체를 사용하면 각 View가 명확한 타입을 가지므로 이러한 문제를 피할 수 있습니다.</p><h3 id=5-view-life-cycle>5. View Life Cycle<a hidden class=anchor aria-hidden=true href=#5-view-life-cycle>#</a></h3><p>함수로 반환한 View에도 <code>onAppear</code>, <code>onDisappear</code>, <code>task</code> 같은 생명주기 modifier를 붙일 수는 있습니다. 하지만 함수는 독립적인 identity가 없으므로, 해당 modifier는 부모 View의 생명주기를 따르게 됩니다.</p><p>반면 <strong>구조체</strong>는 자체적인 identity와 lifetime을 가지므로, 생명주기 modifier가 해당 View의 등장/퇴장 시점에 정확히 동작합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>DataFetchingView</span>: View {
</span></span><span style=display:flex><span>    @State <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> data: [Item] = []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some View {
</span></span><span style=display:flex><span>        List(data) { item <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            Text(item.name)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        .onAppear {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// View가 나타날 때 데이터 로드</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        .task {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 비동기 작업 수행</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=정리-언제-무엇을-선택할까>정리: 언제 무엇을 선택할까<a hidden class=anchor aria-hidden=true href=#정리-언제-무엇을-선택할까>#</a></h2><table><thead><tr><th>상황</th><th>선택</th><th>근거</th></tr></thead><tbody><tr><td>자체 상태(<code>@State</code> 등)가 필요할 때</td><td><strong>구조체</strong></td><td>함수는 상태를 가질 수 없음</td></tr><tr><td>여러 화면에서 재사용할 컴포넌트</td><td><strong>구조체</strong></td><td>독립적인 identity와 타입으로 관리 가능</td></tr><tr><td><code>onAppear</code>, <code>task</code> 등 생명주기 활용</td><td><strong>구조체</strong></td><td>의미 있는 lifetime 보장</td></tr><tr><td>복잡한 로직이 포함된 View</td><td><strong>구조체</strong></td><td>명확한 identity로 성능 최적화</td></tr><tr><td>같은 View 내에서 단순 중복 제거</td><td><strong>함수</strong></td><td>빠르고 간편함</td></tr><tr><td>상태 없는 아주 작은 UI 조각</td><td><strong>함수</strong></td><td>오버헤드 없이 간단히 처리</td></tr></tbody></table><hr><h2 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h2><p><strong>기본적으로 구조체 친화적인 SwiftUI는 View를 만들 때 구조체 사용을 권장합니다.</strong>
그리고 상황적으로 유연하게 함수로 View를 그리는 것이 가능합니다.</p><ul><li><strong>재사용·확장성·상태·생명주기가 필요하다 → struct</strong></li><li><strong>한 화면 안에서의 작은 UI 조각 → 함수</strong></li></ul><p>SwiftUI는 Identity, Lifetime, Dependencies라는 원리를 기반으로 작동하는데요,
이 관점에서 보면 struct View는 SwiftUI가 기대하는 방식에 자연스럽게 맞춰져 있고,
함수 기반 View는 역할이 제한적입니다.</p><p>함수는 &ldquo;같은 View 안에서 반복되는 작은 UI 조각을 빠르게 추출"하는 용도로 제한적으로 사용하면 좋습니다.
만약 함수가 점점 복잡해지거나, 상태가 필요해지거나, 다른 곳에서도 쓰이게 된다면 그때 구조체로 승격시키면 됩니다.</p><hr><h2 id=참고-자료>참고 자료<a hidden class=anchor aria-hidden=true href=#참고-자료>#</a></h2><ul><li><a href=https://developer.apple.com/videos/play/wwdc2021/10022/>WWDC21: Demystify SwiftUI</a></li><li><a href=https://developer.apple.com/documentation/swiftui/view>Apple Developer Documentation: View</a></li><li><a href=https://developer.apple.com/documentation/swiftui/state>Apple Developer Documentation: State</a></li><li><a href=https://developer.apple.com/documentation/swiftui/viewbuilder>Apple Developer Documentation: ViewBuilder</a></li><li><a href=https://developer.apple.com/videos/play/wwdc2024/10150/>WWDC24: SwiftUI essentials</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://yeniful.github.io/tags/swiftui/>SwiftUI</a></li><li><a href=http://yeniful.github.io/tags/ios/>IOS</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [SwiftUI] struct View vs @ViewBuilder 함수, 뭐가 다를까? on x" href="https://x.com/intent/tweet/?text=%5bSwiftUI%5d%20struct%20View%20vs%20%40ViewBuilder%20%ed%95%a8%ec%88%98%2c%20%eb%ad%90%ea%b0%80%20%eb%8b%a4%eb%a5%bc%ea%b9%8c%3f&amp;url=http%3a%2f%2fyeniful.github.io%2fposts%2f2025%2f20250301_swiftuiview%2f&amp;hashtags=SwiftUI%2ciOS"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [SwiftUI] struct View vs @ViewBuilder 함수, 뭐가 다를까? on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fyeniful.github.io%2fposts%2f2025%2f20250301_swiftuiview%2f&amp;title=%5bSwiftUI%5d%20struct%20View%20vs%20%40ViewBuilder%20%ed%95%a8%ec%88%98%2c%20%eb%ad%90%ea%b0%80%20%eb%8b%a4%eb%a5%bc%ea%b9%8c%3f&amp;summary=%5bSwiftUI%5d%20struct%20View%20vs%20%40ViewBuilder%20%ed%95%a8%ec%88%98%2c%20%eb%ad%90%ea%b0%80%20%eb%8b%a4%eb%a5%bc%ea%b9%8c%3f&amp;source=http%3a%2f%2fyeniful.github.io%2fposts%2f2025%2f20250301_swiftuiview%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [SwiftUI] struct View vs @ViewBuilder 함수, 뭐가 다를까? on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fyeniful.github.io%2fposts%2f2025%2f20250301_swiftuiview%2f&title=%5bSwiftUI%5d%20struct%20View%20vs%20%40ViewBuilder%20%ed%95%a8%ec%88%98%2c%20%eb%ad%90%ea%b0%80%20%eb%8b%a4%eb%a5%bc%ea%b9%8c%3f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [SwiftUI] struct View vs @ViewBuilder 함수, 뭐가 다를까? on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fyeniful.github.io%2fposts%2f2025%2f20250301_swiftuiview%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [SwiftUI] struct View vs @ViewBuilder 함수, 뭐가 다를까? on whatsapp" href="https://api.whatsapp.com/send?text=%5bSwiftUI%5d%20struct%20View%20vs%20%40ViewBuilder%20%ed%95%a8%ec%88%98%2c%20%eb%ad%90%ea%b0%80%20%eb%8b%a4%eb%a5%bc%ea%b9%8c%3f%20-%20http%3a%2f%2fyeniful.github.io%2fposts%2f2025%2f20250301_swiftuiview%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [SwiftUI] struct View vs @ViewBuilder 함수, 뭐가 다를까? on telegram" href="https://telegram.me/share/url?text=%5bSwiftUI%5d%20struct%20View%20vs%20%40ViewBuilder%20%ed%95%a8%ec%88%98%2c%20%eb%ad%90%ea%b0%80%20%eb%8b%a4%eb%a5%bc%ea%b9%8c%3f&amp;url=http%3a%2f%2fyeniful.github.io%2fposts%2f2025%2f20250301_swiftuiview%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [SwiftUI] struct View vs @ViewBuilder 함수, 뭐가 다를까? on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5bSwiftUI%5d%20struct%20View%20vs%20%40ViewBuilder%20%ed%95%a8%ec%88%98%2c%20%eb%ad%90%ea%b0%80%20%eb%8b%a4%eb%a5%bc%ea%b9%8c%3f&u=http%3a%2f%2fyeniful.github.io%2fposts%2f2025%2f20250301_swiftuiview%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><section class="comments-section giscus-section"><h3>GitHub Comments</h3><script src=https://giscus.app/client.js data-repo=yeniful/yeniful.github.io data-repo-id=R_kgDOKBynsw data-category-id=DIC_kwDOKByns84CrZhr data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></section><style>.comments-section{margin:3rem 0;padding:2rem 0}.giscus-section{margin-bottom:1rem}</style></article></main><footer class=footer><span>&copy; 2026 <a href=http://yeniful.github.io/>@yeniful blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>