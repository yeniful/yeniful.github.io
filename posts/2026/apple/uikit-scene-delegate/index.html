<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[UIKit] Scene Delegate | @yeniful blog</title><meta name=keywords content="UIKit,Apple,iOS"><meta name=description content="iOS 13부터 도입된 SceneDelegate의 역할, 도입 배경, 각 메서드의 동작 원리 알아보기."><meta name=author content><link rel=canonical href=http://yeniful.github.io/posts/2026/apple/uikit-scene-delegate/><link crossorigin=anonymous href=/assets/css/stylesheet.820607a6a83d36316fff1fed0bc0945a205262a9268e6d4eb781faabeb3ac19b.css integrity="sha256-ggYHpqg9NjFv/x/tC8CUWiBSYqkmjm1Ot4H6q+s6wZs=" rel="preload stylesheet" as=style><link rel=icon href=http://yeniful.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://yeniful.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://yeniful.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://yeniful.github.io/apple-touch-icon.png><link rel=mask-icon href=http://yeniful.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://yeniful.github.io/posts/2026/apple/uikit-scene-delegate/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://yeniful.github.io/posts/2026/apple/uikit-scene-delegate/"><meta property="og:site_name" content="@yeniful blog"><meta property="og:title" content="[UIKit] Scene Delegate"><meta property="og:description" content="iOS 13부터 도입된 SceneDelegate의 역할, 도입 배경, 각 메서드의 동작 원리 알아보기."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-01T00:00:00+09:00"><meta property="article:modified_time" content="2026-01-01T00:00:00+09:00"><meta property="article:tag" content="UIKit"><meta property="article:tag" content="Apple"><meta property="article:tag" content="IOS"><meta name=twitter:card content="summary"><meta name=twitter:title content="[UIKit] Scene Delegate"><meta name=twitter:description content="iOS 13부터 도입된 SceneDelegate의 역할, 도입 배경, 각 메서드의 동작 원리 알아보기."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://yeniful.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[UIKit] Scene Delegate","item":"http://yeniful.github.io/posts/2026/apple/uikit-scene-delegate/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[UIKit] Scene Delegate","name":"[UIKit] Scene Delegate","description":"iOS 13부터 도입된 SceneDelegate의 역할, 도입 배경, 각 메서드의 동작 원리 알아보기.","keywords":["UIKit","Apple","iOS"],"articleBody":"Motivation iOS 13+ 씬 기반 UIKit 프로젝트는 AppDelegate와 SceneDelegate가 함께 생성된다. Storyboard를 쓰는 기본 템플릿에서는 시스템이 UIWindow를 생성/연결한다. Programmatic UI를 쓰면 scene(_:willConnectTo:)에서 UIWindow를 직접 구성해야 한다. SceneDelegate의 역할은 무엇일까? Overview AppDelegate는 프로세스 수준 이벤트와 Scene session 생성/폐기를 관리한다. SceneDelegate는 각 Scene의 UI 생명주기와 UI 설정을 관리한다. iOS 12까지 AppDelegate가 UI 생명주기까지 담당했지만, iOS 13부터 하나의 앱이 여러 UI 인스턴스(Scene)를 가질 수 있게 되면서 역할이 분리되었다. 씬 기반 라이프사이클을 채택하면 UIApplicationDelegate의 UI 관련 콜백은 호출되지 않고, SceneDelegate 메서드가 1:1로 대응된다. 이 글에서는 SceneDelegate의 역할과 각 메서드의 동작 원리를 알아본다. SceneDelegate란? iOS 13부터 도입된 앱의 화면(UI) 생명주기를 관리하는 객체. AppDelegate에서 UI 상태 관리 역할이 분리되어 나왔다. 도입 배경 WWDC 2019에서 iOS 13 / iPadOS 13의 Scene 기반 라이프사이클과 iPad 멀티 윈도우가 소개되었다. 멀티 윈도우를 지원하려면 각 화면 인스턴스(Scene)마다 독립적인 UI 생명주기 관리가 필요했다. 기존 AppDelegate 구조의 한계 (WWDC19 Session 258) “In iOS 12 and earlier, your application had one process and also just one user interface instance to match it.” “Applications now still share one process but may have multiple user interface instances or scene sessions.”\niOS 12 이전: AppDelegate의 didEnterForeground, willResignActive 등의 메서드는 앱 전체에 대해 한 번만 호출됨 iOS 13 이후: 같은 앱의 창이 여러 개 열려있으면, 각 창이 독립적으로 foreground/background 전환을 해야 함 한계: AppDelegate 하나로는 “어떤 UI가 foreground로 왔는지” 구분할 수 없음 해결: UI 생명주기 관리를 Scene 단위로 분리 → SceneDelegate 도입 iOS 12 이전 iOS 13 이후 구조 1 App = 1 Process = 1 UI 1 App = 1 Process = 여러 UI(Scene) AppDelegate 프로세스 생명주기, UI 상태 모두 관리 프로세스 생명주기 + Scene session 생성/폐기 관리 SceneDelegate 없음 각 Scene의 UI 생명주기 + UI 설정/복원 참고: iOS 9의 Split View는 다른 앱을 나란히 보는 것이고, iOS 13의 멀티 윈도우는 같은 앱의 여러 인스턴스를 동시에 보는 것이다.\nScene 관련 클래스 구조 UISceneSession ──────── UIScene ◀── UIWindowScene │ │ │ .scene 프로퍼티로 참조 │ .windows 프로퍼티로 관리 │ ▼ │ UIWindow │ │ └─ 메타정보/상태 관리 ▼ (state restoration 등) rootViewController 클래스 역할 UISceneSession Scene의 세션 메타정보를 담고, 시스템이 세션을 추적/유지한다. UIScene 앱 UI의 하나의 인스턴스를 나타내는 추상 클래스. UIWindowScene UIScene의 구체적인 서브클래스. UIWindow를 표시할 환경을 제공한다. UIWindow 앱의 UI를 담는 컨테이너. rootViewController를 통해 화면에 뷰를 표시한다. SceneDelegate는 UIWindowSceneDelegate 프로토콜을 채택하여 UIWindowScene의 생명주기 이벤트를 처리한다.\nScene ≠ Window Scene과 Window는 다른 개념이다. Scene은 앱 UI 인스턴스(세션)이고, Window는 화면에 그려지는 컨테이너다. 멀티 윈도우(iPadOS)는 같은 앱의 여러 Scene을 동시에 보여주는 것에 가깝다. 보통 1 Scene = 1 `UIWindow 구성으로 사용하는 경우가 많다. Scene Configuration (Info.plist / 코드) 시스템은 새 Scene을 만들기 전에 application(_:configurationForConnecting:options:)를 호출해 어떤 Scene 구성을 쓸지 묻는다. 이 구성에는 SceneDelegate 클래스, Storyboard 이름, (선택적으로) Scene 서브클래스가 포함된다. 구성은 Info.plist에 정적으로 선언하거나 런타임에 동적으로 생성할 수 있다. options에는 user activity, URL context 등이 포함되어 어떤 Scene을 열지 결정하는 힌트를 제공한다. SceneDelegate 메서드 프로젝트를 생성했을 때 SceneDelegate.swift 파일 구성은 다음과 같다. import UIKit class SceneDelegate: UIResponder, UIWindowSceneDelegate { var window: UIWindow? func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) { guard let _ = (scene as? UIWindowScene) else { return } } func sceneDidDisconnect(_ scene: UIScene) { ... } func sceneDidBecomeActive(_ scene: UIScene) { ... } func sceneWillResignActive(_ scene: UIScene) { ... } func sceneWillEnterForeground(_ scene: UIScene) { ... } func sceneDidEnterBackground(_ scene: UIScene) { ... } } 각 메서드의 기본 주석들을 함께 읽어보자 func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) - Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`. - If using a storyboard, the `window` property will automatically be initialized and attached to the scene. - This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead). scene() 메서드를 통해 UIWindow를 설정하고 UIWindowScene에 연결하세요. Storyboard를 사용하면 window 프로퍼티가 자동으로 초기화되고 scene에 연결됩니다. 이 delegate가 호출된다고 해서 연결되는 scene이나 session이 새로운 것은 아닙니다. scene이 앱에 연결될 때 호출된다. Programmatic UI를 사용하면 이 메서드에서 UIWindow를 직접 생성하고 rootViewController를 설정해야 한다.\nfunc sceneDidDisconnect(_ scene: UIScene) - Called as the scene is being released by the system. - This occurs shortly after the scene enters the background, or when its session is discarded. - Release any resources associated with this scene that can be re-created the next time the scene connects. - The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead). sceneDidDisconnect()는 시스템이 scene을 해제할 때 호출됩니다. 백그라운드 진입 직후일 수도 있지만, 시스템이 필요할 때 언제든 호출될 수 있습니다. 다음에 scene이 다시 연결될 때 재생성할 수 있는 리소스를 해제하세요. scene이 나중에 다시 연결될 수 있습니다. 세션이 반드시 삭제되는 것은 아닙니다. 시스템이 리소스를 회수하기 위해 scene을 해제할 때 호출될 수 있다. 완전히 종료된 것이 아니므로, 나중에 다시 연결될 수 있다.\nfunc sceneDidBecomeActive(_ scene: UIScene) - Called when the scene has moved from an inactive state to an active state. - Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive. scene이 비활성 상태에서 활성 상태로 전환될 때 호출됩니다. scene이 비활성 상태일 때 일시 중지되었거나 아직 시작되지 않은 작업을 재시작하세요. func sceneWillResignActive(_ scene: UIScene) - Called when the scene will move from an active state to an inactive state. - This may occur due to temporary interruptions (ex. an incoming phone call). scene이 활성 상태에서 비활성 상태로 전환될 때 호출됩니다. 일시적인 중단(예: 전화 수신)으로 인해 발생할 수 있습니다. func sceneWillEnterForeground(_ scene: UIScene) - Called as the scene transitions from the background to the foreground. - Use this method to undo the changes made on entering the background. scene이 백그라운드에서 포그라운드로 전환될 때 호출됩니다. 이 메서드를 통해 백그라운드 진입 시 만든 변경사항을 되돌리세요. sceneDidEnterBackground(_ scene: UIScene) - Called as the scene transitions from the foreground to the background. - Use this method to save data, release shared resources, and store enough scene-specific state information to restore the scene back to its current state. scene이 포그라운드에서 백그라운드로 전환될 때 호출됩니다. 이 메서드를 통해 다음의 작업을 하세요. 데이터 저장 공유 리소스 해제 scene을 현재 상태로 복구하기에 충분한 씬별 상태 정보를 저장. Scene 생명주기 흐름 ┌─────────────────────────────────────┐ │ App Launch │ └─────────────────┬───────────────────┘ ▼ ┌─────────────────────────────────────┐ │ scene(_:willConnectTo:options:) │ │ Scene 연결 │ └─────────────────┬───────────────────┘ ▼ ┌─────────────────────────────────────┐ │ sceneWillEnterForeground(_:) │ │ 포그라운드 진입 예정 │ └─────────────────┬───────────────────┘ ▼ ┌─────────────────────────────────────────────────────────┐ │ sceneDidBecomeActive(_:) │ │ 활성 상태 전환 │ └───────────────────────────┬─────────────────────────────┘ │ ┌───────────┴───────────┐ ▼ ▼ ┌──────────────────────────┐ ┌──────────────────────────┐ │ sceneWillResignActive(_:)│ │ (사용자가 앱 사용 중) │ │ 비활성 상태 전환 예정 │ │ │ └────────────┬─────────────┘ └──────────────────────────┘ ▼ ┌──────────────────────────┐ │ sceneDidEnterBackground │ │ 백그라운드 진입 │ └────────────┬─────────────┘ ▼ ┌──────────────────────────┐ │ sceneDidDisconnect(_:) │ │ 시스템이 Scene 해제 │ └──────────────────────────┘ 참고: sceneWillEnterForeground는 정의상 백그라운드 → 포그라운드 전환 시 호출된다. 첫 연결 직후 이어지는 흐름에서도 호출될 수 있지만, 공식 의미는 “foreground 진입”이다.\n참고: sceneDidDisconnect는 백그라운드 진입 직후뿐 아니라 언제든 호출될 수 있으며, 항상 발생하는 단계는 아니다.\n메서드 활용 예시 메서드 활용 예시 scene(_:willConnectTo:options:) UIWindow 생성, rootViewController 설정 sceneDidDisconnect(_:) 재생성 가능한 리소스 해제, 캐시 정리 sceneDidBecomeActive(_:) 타이머 재시작, 애니메이션 재개, 데이터 새로고침 sceneWillResignActive(_:) 게임 일시정지, 타이머 중지, 진행 중인 작업 저장 sceneWillEnterForeground(_:) 블러 처리 제거, UI 새로고침 sceneDidEnterBackground(_:) 민감한 정보 블러 처리, 데이터 저장, 상태 정보 저장 Storyboard 대신 Programmatic UI 구현하기 Storyboard를 사용하지 않고, 코드를 통한 Programmatic UI 를 구현하려면 먼저 Storyboard가 연결된 값들을 없애주어야 한다. Info.plist의 Scene Configuration에서 Storyboard Name을 제거한다. ![[Screenshot 2026-01-22 at 18.11.26.png]] SceneDelegate의 가장 첫번 째 메서드인 func scene()을 다음과 같이 수정해준다. var window: UIWindow? func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) { guard let windowScene = (scene as? UIWindowScene) else { return } let window = UIWindow(windowScene: windowScene) // 객체 생성 window.rootViewController = ViewController() window.makeKeyAndVisible() self.window = window // 생성 후나중에 할당 } 주로 아래의 방식으로 할당했었는데, 위처럼 객체를 완성하고 나중에 할당하는 패턴이 Swift에서 권장되는 패턴이라고 한다. guard let windowScene = (scene as? UIWindowScene) else { return } window = UIWindow(windowScene: windowScene) window?.rootViewController = ViewController() window?.makeKeyAndVisible() 추가 설명\nScene Configuration에 storyboard가 지정되어 있으면, 시스템이 해당 storyboard로 window를 생성/연결한다. Info.plist / Scene Configuration / Storyboard Name 값에서 시작 스토리보드를 지정해줄 수 있다. 기본 템플릿에서는 ViewController가 초기 루트로 설정되어 있다. Q\u0026A Q: iOS 13 미만을 지원하려면 SceneDelegate를 어떻게 처리해야 할까? @available(iOS 13.0, *) 어노테이션을 SceneDelegate 클래스에 추가한다. AppDelegate에서 window 프로퍼티를 선언하고, iOS 12 이하에서는 AppDelegate에서 UI를 설정한다. 백포트 시 AppDelegate/SceneDelegate를 둘 다 두면 UIKit이 런타임에 올바른 쪽을 호출한다. Q: sceneDidDisconnect와 앱 종료는 같은 건가? 아니다. sceneDidDisconnect는 시스템이 Scene을 해제할 때 호출된다. 백그라운드 직후뿐 아니라 언제든 호출될 수 있다. Scene의 세션(UISceneSession)은 유지될 수 있으며, 사용자가 다시 앱으로 돌아오면 Scene이 재연결될 수 있다. 세션이 영구 폐기되면 AppDelegate의 application(_:didDiscardSceneSessions:)에서 정리한다. 이 콜백은 다음 실행 직후 호출될 수도 있다. Q: Foreground/Background와 Active/Inactive의 차이는? Foreground/Background: 앱이 화면에 보이는지 여부 Foreground: 화면에 보임 Background: 화면에 안 보임 Active/Inactive: 앱이 이벤트를 받을 수 있는지 여부 Active: 터치 이벤트 등을 받을 수 있음 Inactive: 화면에 보이지만 이벤트를 받지 못함 (예: 전화 수신, 제어 센터 열기) Q: 왜 scene(_:willConnectTo:)에서 guard let으로 UIWindowScene을 캐스팅할까? scene 파라미터의 타입은 UIScene(추상 클래스)이다. UIWindow를 생성하려면 구체적인 서브클래스인 UIWindowScene이 필요하다. 다운캐스팅에 실패하면 윈도우를 만들 수 없으므로 early return 한다. Q: AppDelegate의 application(_:didFinishLaunchingWithOptions:)는 언제 호출되나? iOS 13 이후에도 여전히 호출된다. 앱 프로세스가 시작될 때 가장 먼저 호출되며, Scene 구성/연결보다 먼저 실행된다. 앱 전체에서 공유하는 초기 설정(Firebase, 로깅 등)은 여기서 하면 된다. Q: iPhone(iOS)에서는 여러 Scene을 사용하지 않는 건가? iOS에서는 일반적으로 하나의 Scene을 설계하고, iPadOS/macOS에서는 여러 Scene을 고려한다. 하지만 SceneDelegate 구조가 iPhone에서도 기본 템플릿으로 제공되는 이유: iPad와 코드를 공유할 때 유리함 향후 확장성과 코드 일관성을 위해 Q: SwiftUI는 SceneDelegate를 어떻게 처리할까? SwiftUI는 SceneDelegate를 직접 사용하지 않는다. 대신 App 프로토콜과 Scene 프로토콜로 추상화되어 있다. @main struct MyApp: App { var body: some Scene { WindowGroup { ContentView() } } } WindowGroup은 SwiftUI가 제공하는 대표적인 Scene 컨테이너다. 생명주기 이벤트는 scenePhase 환경 변수로 감지할 수 있다. @Environment(\\.scenePhase) var scenePhase var body: some View { ContentView() .onChange(of: scenePhase) { phase in switch phase { case .active: // sceneDidBecomeActive case .inactive: // sceneWillResignActive case .background: // sceneDidEnterBackground } } } AppDelegate나 SceneDelegate가 필요하면 @UIApplicationDelegateAdaptor를 사용할 수 있다. 참고 (공식) WWDC19: Architecting Your App for Multiple Windows (Video)\nhttps://developer.apple.com/videos/play/wwdc2019/258/ WWDC19: Architecting Your App for Multiple Windows (Slides PDF)\nhttps://devstreaming-cdn.apple.com/videos/wwdc/2019/258ggtahutefvsda35yt/258/258_architecting_your_app_for_multiple_windows.pdf UIApplicationDelegate (Scene configuration / discard sessions)\nhttps://developer.apple.com/documentation/uikit/uiapplicationdelegate UISceneDelegate (Scene lifecycle)\nhttps://developer.apple.com/documentation/uikit/uiscenedelegate SwiftUI Tutorial: Responding to events (Scene architecture / scenePhase)\nhttps://developer.apple.com/tutorials/app-dev-training/responding-to-events ","wordCount":"1645","inLanguage":"en","datePublished":"2026-01-01T00:00:00+09:00","dateModified":"2026-01-01T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://yeniful.github.io/posts/2026/apple/uikit-scene-delegate/"},"publisher":{"@type":"Organization","name":"@yeniful blog","logo":{"@type":"ImageObject","url":"http://yeniful.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://yeniful.github.io/ accesskey=h title="@yeniful blog (Alt + H)">@yeniful blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://yeniful.github.io/ title=Home><span>Home</span></a></li><li><a href=http://yeniful.github.io/category/ title=Category><span>Category</span></a></li><li><a href=http://yeniful.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=http://yeniful.github.io/notice/ title=Notice><span>Notice</span></a></li><li><a href=http://yeniful.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[UIKit] Scene Delegate</h1><div class=post-meta><span title='2026-01-01 00:00:00 +0900 +0900'>January 1, 2026</span>&nbsp;·&nbsp;8 min</div></header><div class=post-content><h2 id=motivation>Motivation<a hidden class=anchor aria-hidden=true href=#motivation>#</a></h2><ul><li>iOS 13+ 씬 기반 UIKit 프로젝트는 <code>AppDelegate</code>와 <code>SceneDelegate</code>가 함께 생성된다.</li><li>Storyboard를 쓰는 기본 템플릿에서는 시스템이 <code>UIWindow</code>를 생성/연결한다.</li><li>Programmatic UI를 쓰면 <code>scene(_:willConnectTo:)</code>에서 <code>UIWindow</code>를 직접 구성해야 한다.</li><li>SceneDelegate의 역할은 무엇일까?</li></ul><h2 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h2><ul><li><code>AppDelegate</code>는 <strong>프로세스 수준 이벤트</strong>와 <strong>Scene session 생성/폐기</strong>를 관리한다.</li><li><code>SceneDelegate</code>는 <strong>각 Scene의 UI 생명주기와 UI 설정</strong>을 관리한다.</li><li>iOS 12까지 <code>AppDelegate</code>가 UI 생명주기까지 담당했지만, iOS 13부터 하나의 앱이 여러 UI 인스턴스(Scene)를 가질 수 있게 되면서 역할이 분리되었다.</li><li>씬 기반 라이프사이클을 채택하면 UIApplicationDelegate의 UI 관련 콜백은 호출되지 않고, SceneDelegate 메서드가 1:1로 대응된다.</li><li>이 글에서는 <code>SceneDelegate</code>의 역할과 각 메서드의 동작 원리를 알아본다.</li></ul><h2 id=scenedelegate란>SceneDelegate란?<a hidden class=anchor aria-hidden=true href=#scenedelegate란>#</a></h2><ul><li>iOS 13부터 도입된 앱의 화면(UI) 생명주기를 관리하는 객체.</li><li>AppDelegate에서 UI 상태 관리 역할이 분리되어 나왔다.</li></ul><h2 id=도입-배경>도입 배경<a hidden class=anchor aria-hidden=true href=#도입-배경>#</a></h2><ul><li><strong>WWDC 2019</strong>에서 iOS 13 / iPadOS 13의 <strong>Scene 기반 라이프사이클</strong>과 iPad 멀티 윈도우가 소개되었다.</li><li>멀티 윈도우를 지원하려면 각 화면 인스턴스(Scene)마다 독립적인 UI 생명주기 관리가 필요했다.</li></ul><h4 id=기존-appdelegate-구조의-한계-wwdc19-session-258>기존 AppDelegate 구조의 한계 (WWDC19 Session 258)<a hidden class=anchor aria-hidden=true href=#기존-appdelegate-구조의-한계-wwdc19-session-258>#</a></h4><blockquote><p><em>&ldquo;In iOS 12 and earlier, your application had <strong>one process</strong> and also just <strong>one user interface instance</strong> to match it.&rdquo;</em>
<em>&ldquo;Applications now still share <strong>one process</strong> but may have <strong>multiple user interface instances or scene sessions</strong>.&rdquo;</em></p></blockquote><ul><li>iOS 12 이전: AppDelegate의 <code>didEnterForeground</code>, <code>willResignActive</code> 등의 메서드는 <strong>앱 전체에 대해 한 번만 호출</strong>됨</li><li>iOS 13 이후: 같은 앱의 창이 여러 개 열려있으면, 각 창이 <strong>독립적으로</strong> foreground/background 전환을 해야 함</li><li><strong>한계</strong>: AppDelegate 하나로는 &ldquo;어떤 UI가 foreground로 왔는지&rdquo; 구분할 수 없음</li><li><strong>해결</strong>: UI 생명주기 관리를 Scene 단위로 분리 → SceneDelegate 도입</li></ul><table><thead><tr><th></th><th>iOS 12 이전</th><th>iOS 13 이후</th></tr></thead><tbody><tr><td>구조</td><td>1 App = 1 Process = 1 UI</td><td>1 App = 1 Process = <strong>여러 UI(Scene)</strong></td></tr><tr><td>AppDelegate</td><td>프로세스 생명주기, UI 상태 모두 관리</td><td>프로세스 생명주기 + <strong>Scene session 생성/폐기</strong> 관리</td></tr><tr><td>SceneDelegate</td><td>없음</td><td>각 Scene의 UI 생명주기 + UI 설정/복원</td></tr></tbody></table><blockquote><p>참고: iOS 9의 Split View는 <strong>다른 앱</strong>을 나란히 보는 것이고, iOS 13의 멀티 윈도우는 <strong>같은 앱의 여러 인스턴스</strong>를 동시에 보는 것이다.</p></blockquote><h2 id=scene-관련-클래스-구조>Scene 관련 클래스 구조<a hidden class=anchor aria-hidden=true href=#scene-관련-클래스-구조>#</a></h2><pre tabindex=0><code>UISceneSession ──────── UIScene ◀── UIWindowScene
       │                                   │
       │ .scene 프로퍼티로 참조                │ .windows 프로퍼티로 관리
       │                                   ▼
       │                              UIWindow
       │                                   │
       └─ 메타정보/상태 관리                    ▼
          (state restoration 등)     rootViewController
</code></pre><table><thead><tr><th>클래스</th><th>역할</th></tr></thead><tbody><tr><td><strong>UISceneSession</strong></td><td>Scene의 세션 메타정보를 담고, 시스템이 세션을 추적/유지한다.</td></tr><tr><td><strong>UIScene</strong></td><td>앱 UI의 하나의 인스턴스를 나타내는 추상 클래스.</td></tr><tr><td><strong>UIWindowScene</strong></td><td>UIScene의 구체적인 서브클래스. UIWindow를 표시할 환경을 제공한다.</td></tr><tr><td><strong>UIWindow</strong></td><td>앱의 UI를 담는 컨테이너. rootViewController를 통해 화면에 뷰를 표시한다.</td></tr></tbody></table><blockquote><p>SceneDelegate는 <code>UIWindowSceneDelegate</code> 프로토콜을 채택하여 UIWindowScene의 생명주기 이벤트를 처리한다.</p></blockquote><h4 id=scene--window>Scene ≠ Window<a hidden class=anchor aria-hidden=true href=#scene--window>#</a></h4><ul><li><strong>Scene과 Window는 다른 개념이다.</strong></li><li><strong>Scene</strong>은 앱 UI 인스턴스(세션)이고, <strong>Window</strong>는 화면에 그려지는 컨테이너다.</li><li>멀티 윈도우(iPadOS)는 같은 앱의 여러 <code>Scene</code>을 동시에 보여주는 것에 가깝다.</li><li>보통 1 <code>Scene</code> = 1 `UIWindow 구성으로 사용하는 경우가 많다.</li></ul><h2 id=scene-configuration-infoplist--코드>Scene Configuration (Info.plist / 코드)<a hidden class=anchor aria-hidden=true href=#scene-configuration-infoplist--코드>#</a></h2><ul><li>시스템은 새 Scene을 만들기 전에 <code>application(_:configurationForConnecting:options:)</code>를 호출해 어떤 Scene 구성을 쓸지 묻는다.</li><li>이 구성에는 <strong>SceneDelegate 클래스</strong>, <strong>Storyboard 이름</strong>, (선택적으로) <strong>Scene 서브클래스</strong>가 포함된다.</li><li>구성은 Info.plist에 <strong>정적으로 선언</strong>하거나 런타임에 <strong>동적으로 생성</strong>할 수 있다.</li><li><code>options</code>에는 user activity, URL context 등이 포함되어 어떤 Scene을 열지 결정하는 힌트를 제공한다.</li></ul><h2 id=scenedelegate-메서드>SceneDelegate 메서드<a hidden class=anchor aria-hidden=true href=#scenedelegate-메서드>#</a></h2><ul><li>프로젝트를 생성했을 때 <code>SceneDelegate.swift </code>파일 구성은 다음과 같다.</li></ul><pre tabindex=0><code>import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {
    
    var window: UIWindow?
	
	func scene(_ scene: UIScene, 
				willConnectTo session: UISceneSession, 
				options connectionOptions: UIScene.ConnectionOptions) {
	
		guard let _ = (scene as? UIWindowScene) else { return }

    }

    func sceneDidDisconnect(_ scene: UIScene) { ... }
    func sceneDidBecomeActive(_ scene: UIScene) { ... }
    func sceneWillResignActive(_ scene: UIScene) { ... }
    func sceneWillEnterForeground(_ scene: UIScene) { ... }
    func sceneDidEnterBackground(_ scene: UIScene) { ... }

}
</code></pre><ul><li>각 메서드의 기본 주석들을 함께 읽어보자</li></ul><h5 class=.. id=func-scene_-scene-uiscene-willconnectto-session-uiscenesession-options-connectionoptions-uisceneconnectionoptions>func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions)</h5><pre tabindex=0><code>- Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
- If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
- This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
</code></pre><ul><li><code>scene()</code> 메서드를 통해 <code>UIWindow</code>를 설정하고 <code>UIWindowScene</code>에 연결하세요.</li><li>Storyboard를 사용하면 <code>window</code> 프로퍼티가 자동으로 초기화되고 <code>scene</code>에 연결됩니다.</li><li>이 delegate가 호출된다고 해서 연결되는 scene이나 session이 새로운 것은 아닙니다.</li></ul><blockquote><p>scene이 앱에 <strong>연결될 때</strong> 호출된다. Programmatic UI를 사용하면 이 메서드에서 UIWindow를 직접 생성하고 rootViewController를 설정해야 한다.</p></blockquote><h5 class=.. id=func-scenediddisconnect_-scene-uiscene>func sceneDidDisconnect(_ scene: UIScene)</h5><pre tabindex=0><code>- Called as the scene is being released by the system.
- This occurs shortly after the scene enters the background, or when its session is discarded.
- Release any resources associated with this scene that can be re-created the next time the scene connects.
- The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead).
</code></pre><ul><li><code>sceneDidDisconnect()</code>는 시스템이 scene을 <strong>해제할 때</strong> 호출됩니다.</li><li>백그라운드 진입 직후일 수도 있지만, 시스템이 필요할 때 <strong>언제든</strong> 호출될 수 있습니다.</li><li>다음에 scene이 다시 연결될 때 재생성할 수 있는 리소스를 해제하세요.</li><li>scene이 나중에 다시 연결될 수 있습니다. 세션이 반드시 삭제되는 것은 아닙니다.</li></ul><blockquote><p>시스템이 리소스를 회수하기 위해 scene을 해제할 때 호출될 수 있다. 완전히 종료된 것이 아니므로, 나중에 다시 연결될 수 있다.</p></blockquote><h5 class=.. id=func-scenedidbecomeactive_-scene-uiscene>func sceneDidBecomeActive(_ scene: UIScene)</h5><pre tabindex=0><code>- Called when the scene has moved from an inactive state to an active state.
- Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
</code></pre><ul><li>scene이 비활성 상태에서 <strong>활성 상태로 전환될 때</strong> 호출됩니다.</li><li>scene이 비활성 상태일 때 일시 중지되었거나 아직 시작되지 않은 작업을 재시작하세요.</li></ul><h5 class=.. id=func-scenewillresignactive_-scene-uiscene>func sceneWillResignActive(_ scene: UIScene)</h5><pre tabindex=0><code>- Called when the scene will move from an active state to an inactive state.
- This may occur due to temporary interruptions (ex. an incoming phone call).
</code></pre><ul><li>scene이 활성 상태에서 <strong>비활성 상태로 전환될 때</strong> 호출됩니다.</li><li>일시적인 중단(예: 전화 수신)으로 인해 발생할 수 있습니다.</li></ul><h5 class=.. id=func-scenewillenterforeground_-scene-uiscene>func sceneWillEnterForeground(_ scene: UIScene)</h5><pre tabindex=0><code>- Called as the scene transitions from the background to the foreground.
- Use this method to undo the changes made on entering the background.
</code></pre><ul><li>scene이 백그라운드에서 <strong>포그라운드로 전환될 때</strong> 호출됩니다.</li><li>이 메서드를 통해 백그라운드 진입 시 만든 변경사항을 되돌리세요.</li></ul><h5 class=.. id=scenedidenterbackground_-scene-uiscene>sceneDidEnterBackground(_ scene: UIScene)</h5><pre tabindex=0><code>- Called as the scene transitions from the foreground to the background.
- Use this method to save data, release shared resources, and store enough scene-specific state information to restore the scene back to its current state.
</code></pre><ul><li><code>scene</code>이 포그라운드에서 <strong>백그라운드로 전환</strong>될 때 호출됩니다.</li><li>이 메서드를 통해 다음의 작업을 하세요.<ul><li>데이터 저장</li><li>공유 리소스 해제</li><li><code>scene</code>을 현재 상태로 복구하기에 충분한 씬별 상태 정보를 저장.</li></ul></li></ul><h2 id=scene-생명주기-흐름>Scene 생명주기 흐름<a hidden class=anchor aria-hidden=true href=#scene-생명주기-흐름>#</a></h2><pre tabindex=0><code>			┌─────────────────────────────────────┐
			│           App Launch                │
			└─────────────────┬───────────────────┘
							  ▼
			┌─────────────────────────────────────┐
			│   scene(_:willConnectTo:options:)   │
			│           Scene 연결                 │
			└─────────────────┬───────────────────┘
							  ▼
			┌─────────────────────────────────────┐
			│     sceneWillEnterForeground(_:)    │
			│         포그라운드 진입 예정             │
			└─────────────────┬───────────────────┘
							  ▼
  ┌─────────────────────────────────────────────────────────┐
  │                  sceneDidBecomeActive(_:)               │
  │                      활성 상태 전환                       │
  └───────────────────────────┬─────────────────────────────┘
							  │
				  ┌───────────┴───────────┐
				  ▼                       ▼
┌──────────────────────────┐   ┌──────────────────────────┐
│ sceneWillResignActive(_:)│   │  (사용자가 앱 사용 중)     │
│    비활성 상태 전환 예정       │   │                          │
└────────────┬─────────────┘   └──────────────────────────┘
			 ▼
┌──────────────────────────┐
│ sceneDidEnterBackground  │
│      백그라운드 진입         │
└────────────┬─────────────┘
			 ▼
┌──────────────────────────┐
│  sceneDidDisconnect(_:)  │
│    시스템이 Scene 해제       │
└──────────────────────────┘
</code></pre><blockquote><p><strong>참고</strong>: <code>sceneWillEnterForeground</code>는 정의상 <strong>백그라운드 → 포그라운드 전환</strong> 시 호출된다. 첫 연결 직후 이어지는 흐름에서도 호출될 수 있지만, 공식 의미는 “foreground 진입”이다.<br><strong>참고</strong>: <code>sceneDidDisconnect</code>는 백그라운드 진입 직후뿐 아니라 <strong>언제든 호출될 수 있으며</strong>, 항상 발생하는 단계는 아니다.</p></blockquote><h2 id=메서드-활용-예시>메서드 활용 예시<a hidden class=anchor aria-hidden=true href=#메서드-활용-예시>#</a></h2><table><thead><tr><th>메서드</th><th>활용 예시</th></tr></thead><tbody><tr><td><code>scene(_:willConnectTo:options:)</code></td><td>UIWindow 생성, rootViewController 설정</td></tr><tr><td><code>sceneDidDisconnect(_:)</code></td><td>재생성 가능한 리소스 해제, 캐시 정리</td></tr><tr><td><code>sceneDidBecomeActive(_:)</code></td><td>타이머 재시작, 애니메이션 재개, 데이터 새로고침</td></tr><tr><td><code>sceneWillResignActive(_:)</code></td><td>게임 일시정지, 타이머 중지, 진행 중인 작업 저장</td></tr><tr><td><code>sceneWillEnterForeground(_:)</code></td><td>블러 처리 제거, UI 새로고침</td></tr><tr><td><code>sceneDidEnterBackground(_:)</code></td><td>민감한 정보 블러 처리, 데이터 저장, 상태 정보 저장</td></tr></tbody></table><h2 id=storyboard-대신-programmatic-ui-구현하기>Storyboard 대신 Programmatic UI 구현하기<a hidden class=anchor aria-hidden=true href=#storyboard-대신-programmatic-ui-구현하기>#</a></h2><ul><li>Storyboard를 사용하지 않고, 코드를 통한 Programmatic UI 를 구현하려면 먼저 Storyboard가 연결된 값들을 없애주어야 한다.<ul><li>Info.plist의 Scene Configuration에서 Storyboard Name을 제거한다. ![[Screenshot 2026-01-22 at 18.11.26.png]]</li></ul></li><li>SceneDelegate의 가장 첫번 째 메서드인 <code>func scene()</code>을 다음과 같이 수정해준다.</li></ul><pre tabindex=0><code>    var window: UIWindow?
    
	func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {

		guard let windowScene = (scene as? UIWindowScene) else { return }
		let window = UIWindow(windowScene: windowScene) // 객체 생성
		window.rootViewController = ViewController()
		window.makeKeyAndVisible()
		self.window = window // 생성 후나중에 할당
	}
</code></pre><ul><li>주로 아래의 방식으로 할당했었는데, 위처럼 객체를 완성하고 나중에 할당하는 패턴이 Swift에서 권장되는 패턴이라고 한다.</li></ul><pre tabindex=0><code>guard let windowScene = (scene as? UIWindowScene) else { return }
window = UIWindow(windowScene: windowScene)
window?.rootViewController = ViewController()
window?.makeKeyAndVisible()
</code></pre><blockquote></blockquote><p>추가 설명</p><blockquote><ul><li>Scene Configuration에 storyboard가 지정되어 있으면, 시스템이 해당 storyboard로 window를 생성/연결한다.</li><li>Info.plist / Scene Configuration / Storyboard Name 값에서 시작 스토리보드를 지정해줄 수 있다.</li><li>기본 템플릿에서는 ViewController가 초기 루트로 설정되어 있다.</li></ul></blockquote><h2 id=qa>Q&amp;A<a hidden class=anchor aria-hidden=true href=#qa>#</a></h2><h4 id=q-ios-13-미만을-지원하려면-scenedelegate를-어떻게-처리해야-할까>Q: iOS 13 미만을 지원하려면 SceneDelegate를 어떻게 처리해야 할까?<a hidden class=anchor aria-hidden=true href=#q-ios-13-미만을-지원하려면-scenedelegate를-어떻게-처리해야-할까>#</a></h4><ul><li><code>@available(iOS 13.0, *)</code> 어노테이션을 SceneDelegate 클래스에 추가한다.</li><li>AppDelegate에서 <code>window</code> 프로퍼티를 선언하고, iOS 12 이하에서는 AppDelegate에서 UI를 설정한다.</li><li>백포트 시 AppDelegate/SceneDelegate를 <strong>둘 다</strong> 두면 UIKit이 런타임에 올바른 쪽을 호출한다.</li></ul><h4 id=q-scenediddisconnect와-앱-종료는-같은-건가>Q: sceneDidDisconnect와 앱 종료는 같은 건가?<a hidden class=anchor aria-hidden=true href=#q-scenediddisconnect와-앱-종료는-같은-건가>#</a></h4><ul><li><strong>아니다.</strong> <code>sceneDidDisconnect</code>는 시스템이 Scene을 <strong>해제</strong>할 때 호출된다. 백그라운드 직후뿐 아니라 언제든 호출될 수 있다.</li><li>Scene의 세션(UISceneSession)은 유지될 수 있으며, 사용자가 다시 앱으로 돌아오면 Scene이 재연결될 수 있다.</li><li>세션이 <strong>영구 폐기</strong>되면 AppDelegate의 <code>application(_:didDiscardSceneSessions:)</code>에서 정리한다. 이 콜백은 다음 실행 직후 호출될 수도 있다.</li></ul><h4 id=q-foregroundbackground와-activeinactive의-차이는>Q: Foreground/Background와 Active/Inactive의 차이는?<a hidden class=anchor aria-hidden=true href=#q-foregroundbackground와-activeinactive의-차이는>#</a></h4><ul><li><strong>Foreground/Background</strong>: 앱이 화면에 보이는지 여부<ul><li>Foreground: 화면에 보임</li><li>Background: 화면에 안 보임</li></ul></li><li><strong>Active/Inactive</strong>: 앱이 이벤트를 받을 수 있는지 여부<ul><li>Active: 터치 이벤트 등을 받을 수 있음</li><li>Inactive: 화면에 보이지만 이벤트를 받지 못함 (예: 전화 수신, 제어 센터 열기)</li></ul></li></ul><h4 id=q-왜-scene_willconnectto에서-guard-let으로-uiwindowscene을-캐스팅할까>Q: 왜 scene(_:willConnectTo:)에서 guard let으로 UIWindowScene을 캐스팅할까?<a hidden class=anchor aria-hidden=true href=#q-왜-scene_willconnectto에서-guard-let으로-uiwindowscene을-캐스팅할까>#</a></h4><ul><li><code>scene</code> 파라미터의 타입은 <code>UIScene</code>(추상 클래스)이다.</li><li>UIWindow를 생성하려면 구체적인 서브클래스인 <code>UIWindowScene</code>이 필요하다.</li><li>다운캐스팅에 실패하면 윈도우를 만들 수 없으므로 early return 한다.</li></ul><h4 id=q-appdelegate의-application_didfinishlaunchingwithoptions는-언제-호출되나>Q: AppDelegate의 application(_:didFinishLaunchingWithOptions:)는 언제 호출되나?<a hidden class=anchor aria-hidden=true href=#q-appdelegate의-application_didfinishlaunchingwithoptions는-언제-호출되나>#</a></h4><ul><li>iOS 13 이후에도 <strong>여전히 호출된다.</strong></li><li>앱 프로세스가 시작될 때 가장 먼저 호출되며, Scene 구성/연결보다 <strong>먼저</strong> 실행된다.</li><li>앱 전체에서 공유하는 초기 설정(Firebase, 로깅 등)은 여기서 하면 된다.</li></ul><h4 id=q-iphoneios에서는-여러-scene을-사용하지-않는-건가>Q: iPhone(iOS)에서는 여러 Scene을 사용하지 않는 건가?<a hidden class=anchor aria-hidden=true href=#q-iphoneios에서는-여러-scene을-사용하지-않는-건가>#</a></h4><ul><li>iOS에서는 <strong>일반적으로 하나의 Scene</strong>을 설계하고, iPadOS/macOS에서는 여러 Scene을 고려한다.</li><li>하지만 SceneDelegate 구조가 iPhone에서도 기본 템플릿으로 제공되는 이유:<ul><li>iPad와 <strong>코드를 공유</strong>할 때 유리함</li><li>향후 확장성과 코드 일관성을 위해</li></ul></li></ul><h4 id=q-swiftui는-scenedelegate를-어떻게-처리할까>Q: SwiftUI는 SceneDelegate를 어떻게 처리할까?<a hidden class=anchor aria-hidden=true href=#q-swiftui는-scenedelegate를-어떻게-처리할까>#</a></h4><ul><li>SwiftUI는 SceneDelegate를 <strong>직접 사용하지 않는다.</strong></li><li>대신 <code>App</code> 프로토콜과 <code>Scene</code> 프로토콜로 추상화되어 있다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>@main
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyApp</span>: App {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some Scene {
</span></span><span style=display:flex><span>        WindowGroup {
</span></span><span style=display:flex><span>            ContentView()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>WindowGroup</code>은 SwiftUI가 제공하는 대표적인 Scene 컨테이너다.</li><li>생명주기 이벤트는 <code>scenePhase</code> 환경 변수로 감지할 수 있다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>@Environment(<span style=color:#960050;background-color:#1e0010>\</span>.scenePhase) <span style=color:#66d9ef>var</span> scenePhase
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> body: some View {
</span></span><span style=display:flex><span>    ContentView()
</span></span><span style=display:flex><span>        .onChange(of: scenePhase) { phase <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>switch</span> phase {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> .active: <span style=color:#75715e>// sceneDidBecomeActive</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> .inactive: <span style=color:#75715e>// sceneWillResignActive</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> .background: <span style=color:#75715e>// sceneDidEnterBackground</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>AppDelegate나 SceneDelegate가 필요하면 <code>@UIApplicationDelegateAdaptor</code>를 사용할 수 있다.</li></ul><hr><h2 id=참고-공식>참고 (공식)<a hidden class=anchor aria-hidden=true href=#참고-공식>#</a></h2><ul><li>WWDC19: Architecting Your App for Multiple Windows (Video)<br><a href=https://developer.apple.com/videos/play/wwdc2019/258/>https://developer.apple.com/videos/play/wwdc2019/258/</a></li><li>WWDC19: Architecting Your App for Multiple Windows (Slides PDF)<br><a href=https://devstreaming-cdn.apple.com/videos/wwdc/2019/258ggtahutefvsda35yt/258/258_architecting_your_app_for_multiple_windows.pdf>https://devstreaming-cdn.apple.com/videos/wwdc/2019/258ggtahutefvsda35yt/258/258_architecting_your_app_for_multiple_windows.pdf</a></li><li>UIApplicationDelegate (Scene configuration / discard sessions)<br><a href=https://developer.apple.com/documentation/uikit/uiapplicationdelegate>https://developer.apple.com/documentation/uikit/uiapplicationdelegate</a></li><li>UISceneDelegate (Scene lifecycle)<br><a href=https://developer.apple.com/documentation/uikit/uiscenedelegate>https://developer.apple.com/documentation/uikit/uiscenedelegate</a></li><li>SwiftUI Tutorial: Responding to events (Scene architecture / scenePhase)<br><a href=https://developer.apple.com/tutorials/app-dev-training/responding-to-events>https://developer.apple.com/tutorials/app-dev-training/responding-to-events</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://yeniful.github.io/tags/uikit/>UIKit</a></li><li><a href=http://yeniful.github.io/tags/apple/>Apple</a></li><li><a href=http://yeniful.github.io/tags/ios/>IOS</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [UIKit] Scene Delegate on x" href="https://x.com/intent/tweet/?text=%5bUIKit%5d%20Scene%20Delegate&amp;url=http%3a%2f%2fyeniful.github.io%2fposts%2f2026%2fapple%2fuikit-scene-delegate%2f&amp;hashtags=UIKit%2cApple%2ciOS"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [UIKit] Scene Delegate on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fyeniful.github.io%2fposts%2f2026%2fapple%2fuikit-scene-delegate%2f&amp;title=%5bUIKit%5d%20Scene%20Delegate&amp;summary=%5bUIKit%5d%20Scene%20Delegate&amp;source=http%3a%2f%2fyeniful.github.io%2fposts%2f2026%2fapple%2fuikit-scene-delegate%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [UIKit] Scene Delegate on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fyeniful.github.io%2fposts%2f2026%2fapple%2fuikit-scene-delegate%2f&title=%5bUIKit%5d%20Scene%20Delegate"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [UIKit] Scene Delegate on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fyeniful.github.io%2fposts%2f2026%2fapple%2fuikit-scene-delegate%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [UIKit] Scene Delegate on whatsapp" href="https://api.whatsapp.com/send?text=%5bUIKit%5d%20Scene%20Delegate%20-%20http%3a%2f%2fyeniful.github.io%2fposts%2f2026%2fapple%2fuikit-scene-delegate%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [UIKit] Scene Delegate on telegram" href="https://telegram.me/share/url?text=%5bUIKit%5d%20Scene%20Delegate&amp;url=http%3a%2f%2fyeniful.github.io%2fposts%2f2026%2fapple%2fuikit-scene-delegate%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [UIKit] Scene Delegate on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5bUIKit%5d%20Scene%20Delegate&u=http%3a%2f%2fyeniful.github.io%2fposts%2f2026%2fapple%2fuikit-scene-delegate%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><section class="comments-section giscus-section"><h3>GitHub Comments</h3><script src=https://giscus.app/client.js data-repo=yeniful/yeniful.github.io data-repo-id=R_kgDOKBynsw data-category-id=DIC_kwDOKByns84CrZhr data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></section><section class="comments-section cusdis-section"><h3>Cusdis Comments</h3><div id=cusdis_thread data-host=https://cusdis.com data-app-id=18a3027c-1140-43b9-a278-40a54abe022d data-page-id=c9d7c096e525b90ba31b98a0d2f21394 data-page-url=http://yeniful.github.io/posts/2026/apple/uikit-scene-delegate/ data-page-title="[UIKit] Scene Delegate"></div><script async defer src=https://cusdis.com/js/cusdis.es.js></script></section><style>.comments-section{margin:3rem 0;padding:2rem 0}.giscus-section{border-bottom:2px solid var(--border);margin-bottom:3rem}.cusdis-section{margin-top:3rem}</style></article></main><footer class=footer><span>&copy; 2026 <a href=http://yeniful.github.io/>@yeniful blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>