<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>IOS on @yeniful blog</title><link>http://yeniful.github.io/tags/ios/</link><description>Recent content in IOS on @yeniful blog</description><generator>Hugo -- 0.154.5</generator><language>en-us</language><lastBuildDate>Thu, 01 Jan 2026 00:00:00 +0900</lastBuildDate><atom:link href="http://yeniful.github.io/tags/ios/index.xml" rel="self" type="application/rss+xml"/><item><title>[Swift] weak self</title><link>http://yeniful.github.io/posts/2026/apple/swift-weak-self/</link><pubDate>Thu, 01 Jan 2026 00:00:00 +0900</pubDate><guid>http://yeniful.github.io/posts/2026/apple/swift-weak-self/</guid><description>&lt;h2 id="motivation"&gt;Motivation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;클로저 안의 weak self&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;self: 클래스 인스턴스 참조&lt;/li&gt;
&lt;li&gt;약한 참조&lt;/li&gt;
&lt;li&gt;ARC&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="note"&gt;Note&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;일반적으로 클로저는 클로저 내부에서 변수를 사용할 때 암시적으로 변수를 캡처하지만, 이 경우에는 명시적으로 작성해야 합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;self&lt;/code&gt;를 캡처하려면, 사용할 때 명시적으로 &lt;code&gt;self&lt;/code&gt;를 작성하거나, 클로저의 캡처 리스트에 &lt;code&gt;self&lt;/code&gt;를 포함합니다. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;self&lt;/code&gt;를 명시적으로 작성하는 것은 의도를 분명하게 표현하고, 참조 순환이 없음을 확인하도록 유도하는 역할도 합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="capture-values"&gt;Capture Values&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;클로저는 정의된 주변 컨텍스트로부터 상수와 변수를 캡처할 수 있음.&lt;/li&gt;
&lt;li&gt;상수와 변수를 정의한 원래 범위가 더이상 존재하지 않더라도 본문 내에서 상수와 변수의 값을 참조하고 수정할 수 있음.&lt;/li&gt;
&lt;li&gt;값을 캡처할 수 있는 가장 간단한 클로저 형태는 다른 함수의 본문 내에 작성하는 중첩 함수
&lt;ul&gt;
&lt;li&gt;중첩 함수는 바깥 함수의 어떠한 인자도 캡처할 수 있고 바깥 함수 내에 정의된 상수와 변수를 캡처할 수도 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://bbiguduk.github.io/swift-book-korean/documentation/the-swift-programming-language-korean/closures/#"&gt;https://bbiguduk.github.io/swift-book-korean/documentation/the-swift-programming-language-korean/closures/#&lt;/a&gt;탈출-클로저-Escaping-Closures&lt;/p&gt;</description></item><item><title>[UIKit] Scene Delegate</title><link>http://yeniful.github.io/posts/2026/apple/scene-delegate/</link><pubDate>Thu, 01 Jan 2026 00:00:00 +0900</pubDate><guid>http://yeniful.github.io/posts/2026/apple/scene-delegate/</guid><description>iOS 13부터 도입된 SceneDelegate의 역할, 도입 배경, 각 메서드의 동작 원리 알아보기.</description></item><item><title>[SwiftUI] struct View vs @ViewBuilder 함수, 뭐가 다를까?</title><link>http://yeniful.github.io/posts/2025/20250301_swiftuiview/</link><pubDate>Sat, 01 Mar 2025 00:00:00 +0900</pubDate><guid>http://yeniful.github.io/posts/2025/20250301_swiftuiview/</guid><description>&lt;h2 id="모티베이션"&gt;모티베이션&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;재사용되는 View를 구조체로 빼야 하나, 아니면 그냥 함수로 만들어도 될까?&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;View를 만들 때 특별한 기준 없이 View를 만들 때 습관적으로 구조체를 만들거나, 간단한 건 함수로 처리하곤 했는데요. 앱의 구조와 성능, 유지보수 방식에 꽤 중요한 영향을 준다는 것을 알게 되었고, 간단한 내용이지만 한 번 정리해보고 싶었습니다.&lt;/p&gt;
&lt;p&gt;그래서 이번 글에서는 Apple 공식 문서와 WWDC 세션에서 강조한 원리를 바탕으로 &lt;strong&gt;struct View vs. @ViewBuilder 함수&lt;/strong&gt;의 차이를 정리해보려고 합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="두-가지-방식-살펴보기"&gt;두 가지 방식 살펴보기&lt;/h2&gt;
&lt;p&gt;먼저 동일한 UI를 두 가지 방식으로 만들어봤습니다.&lt;/p&gt;</description></item></channel></rss>